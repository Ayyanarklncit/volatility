#summary Volatility 1.4 Plugin Interface

= Introduction =

This page will describe the interface used to implement standard volatility plugins. 

= Base Class =

Plugins should inherit from the _commands.command_ base class, or any other plugin that descends from it.  A plugin (_command_ object) by default features the following functions:

  * `help`
  * `execute`
  * `calculate`

The `help` function should return a short string describing the plugin, by default this returns the plugin class docstring, and generally will not require overriding.

The `execute` function firsts calls the plugin's calculate function and then returns the results of calculate to an appropriate render function (based on the output command line parameter).  Again, this function should in general not be overridden.

The `calculate` function should carry out the main operation against any memory images being analyzed.  This function takes no arguments and returns a single "data" variable, which can be of any form as long as it is then successfully processed by the plugin's `render_<type>` functions.

== Options ==

Any additional command line parameters should be defined in the `__init__` function of the plugin (rather than outside of the plugin class) so that multiple plugins may make use of the same option identifiers.  These are handled in a very similar fashion to the optparse module that comes with python.  An add_option function is available to specify a parameter name (--name), a short option (-n), and then the action/defaults for storing the variable.

{{{

config = volatility.conf.ConfObject() 

...

   def __init__(self, *args):
       config.add_option('NAME', short_option='n', default=None,
                         help='Description of the NAME option',
                         action='store', type='str')
       commands.command.__init__(self, *args)

...

       if config.NAME == "blah":
           ...

}}}

== Calculating ==

The most basic function required for most plugins is to load and access an address space.  This is now carried out by a stacked address space plugin mechanism.  The loading of an address space is carried out by the `utils.load_as` function.  More details on the stacking mechanism can be found on the [Vol14AddressSpaces Address Spaces] page (see "determining address space ordering").

If a physical layer is required (rather than a paged/process address space), then the `astype` parameter can be provided with a value of "physical", and only physical layers will be returned.

== Rendering ==

The standard output/render type is `text`, and as such every plugin should define a `render_text` function.

Render functions accept a file descriptor (`outfd`) and the data object returned by the `calculate` function.  The file descriptor will operate just like a normal python file object, and normal use will involve the write function.

When outputting function values in a standard fashion, it is recommended to use `"{0}".format(value)`, over the deprecated `"%x" % value`.

*Note*: The file descriptor may not be a real file, but instead directly to the console that the program is run from (stdout).  As such results may be required in real time.  No output should be made in the calculate function, so to reduce the amount of time taken before being able to display the results a [http://docs.python.org/tutorial/classes.html#generators python generator] should be used.