#summary Example usage cases and output for Volatility commands
#labels Featured

This page contains 

<wiki:toc max_depth="3" />

= Image Identification =

== imageinfo ==

If you don't know what type of system your image came from, use the imageinfo command. 

{{{
$ python volatility.py -f win7.dmp imageinfo
Volatile Systems Volatility Framework 1.4_rc1
Determining profile based on KDBG search...
             Suggested Profile : Win7SP0x86
                     AS Layer1 : JKIA32PagedMemory (Kernel AS)
                     AS Layer2 : FileAddressSpace (/Users/M/Desktop/win7.dmp)
                      PAE type : No PAE
                           DTB : 0x185000
                          KDBG : 0x8296cbe8
                          KPCR : 0x8296dc00
             KUSER_SHARED_DATA : 0xffdf0000
           Image date and time : 2010-07-06 22:40:28 
     Image local date and time : 2010-07-06 22:40:28 
                    Image Type : 
}}}

Among other things, the imageinfo output tells you the suggested profile that you should pass as the parameter to --profile=[PROFILE]. It also tells you the address of the KPCR, which you can use like --kpcr=[ADDRESS]. By supplying the profile and KPCR to other Volatility commands, you'll get the most accurate and fastest results possible.

== datetime ==

Use datetime to get the date and time information from when the memory image was acquired. 

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp datetime
Volatile Systems Volatility Framework 1.4_rc1
Image date and time       : 2010-07-06 22:40:28 
Image local date and time : 2010-07-06 22:40:28
}}}

== kdbgscan ==

Use this command to scan for potential KDBG structures. 

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp kdbgscan
Volatile Systems Volatility Framework 1.4_rc1
Potential KDBG structure virtual addresses:
 _KDBG: 0x0296cbe8  (Win7SP0x86)
}}}

== kprcscan ==

Use this command to scan for potential KPCR structures. 

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp kpcrscan
Volatile Systems Volatility Framework 1.4_rc1
Potential KPCR structure virtual addresses:
 _KPCR: 8296dc00
}}}

= Processes and DLLs =

== pslist ==

To list the active processes of a system, use the pslist command. This walks the doubly-linked list known as !PsActiveProcessHead. It does not detect hidden or unlinked processes. 

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp --kpcr=0x8296dc00 pslist
Volatile Systems Volatility Framework 1.4_rc1
Name                 Pid    PPid   Thds   Hnds   Time  
System                    4      0     90    516 2010-07-06 22:28:46       
smss.exe                252      4      2     29 2010-07-06 22:28:46       
csrss.exe               348    340     10    441 2010-07-06 22:28:53       
wininit.exe             384    340      3     73 2010-07-06 22:28:53       
csrss.exe               396    376      8    187 2010-07-06 22:28:53       
winlogon.exe            424    376      5    129 2010-07-06 22:28:54       
services.exe            492    384     12    216 2010-07-06 22:28:54       
lsass.exe               500    384      7    559 2010-07-06 22:28:54       
lsm.exe                 508    384     10    142 2010-07-06 22:28:54       
svchost.exe             616    492     10    348 2010-07-06 22:28:55
[snip]
}}}

The columns display the process ID, the parent process ID, number of threads, number of handles, and date/time when the process started. 

== pstree ==

To view the process listing in tree form, use the pstree command. This enumerates processes using the same technique as pslist, so it will also not show hidden or unlinked processes. Child process are indicated using indention and periods.

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp --kpcr=0x8296dc00 pstree
Volatile Systems Volatility Framework 1.4_rc1
Name                                        Pid    PPid   Thds   Hnds   Time  
 0x84E6E3D8:wininit.exe                        384    340      3     73 2010-07-06 22:28:53       
. 0x8D4CC030:services.exe                      492    384     12    216 2010-07-06 22:28:54       
.. 0x84E19030:svchost.exe                     1920    492      8    115 2010-07-06 22:33:17       
.. 0x8D4E5BB0:schtasks.exe                    2512    492      2     60 2010-07-06 22:39:09       
.. 0x8D7E9030:wsqmcons.exe                    2576    492      1      3 2010-07-06 22:39:11       
.. 0x8D5B18A8:dllhost.exe                     1944    492     16    187 2010-07-06 22:31:21       
.. 0x8D7EE030:taskhost.exe                    1156    492     10    155 2010-07-06 22:37:54       
.. 0x84D79D40:msdtc.exe                        284    492     15    152 2010-07-06 22:31:24       
.. 0x8D6781D8:svchost.exe                     1056    492     16    589 2010-07-06 22:29:31       
.. 0x8D777D40:taskhost.exe                    2520    492     11    224 2010-07-06 22:39:10       
.. 0x8D759470:sdclt.exe                       2504    492      1      4 2010-07-06 22:39:09       
.. 0x8D5574D8:rundll32.exe                    2484    492      1      5 2010-07-06 22:39:08       
.. 0x84D82C08:SearchIndexer.                  1464    492     18    624 2010-07-06 22:33:20       
... 0x8D759760:SearchFilterHo                 1724   1464      6     82 2010-07-06 22:37:36       
... 0x8D55E678:SearchProtocol                 2680   1464      8    231 2010-07-06 22:39:27       
.. 0x8D5CC030:svchost.exe                     1140    492     17    375 2010-07-06 22:29:51
[snip]
}}}

== psscan2 ==

To enumerate processes using pool tag scanning, use the psscan2 command. This can find processes that previously terminated (inactive) and processes that have been hidden or unlinked by a rootkit. 

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp psscan2
Volatile Systems Volatility Framework 1.4_rc1
PID    PPID   Time created             Time exited              Offset     PDB        Remarks
------ ------ ------------------------ ------------------------ ---------- ---------- ----------------
  2568    348 2010-07-06 22:39:11                               0x002cc030 0x09d54000 conhost.exe     
  1944    492 2010-07-06 22:31:21                               0x00ef48a8 0x08d61000 dllhost.exe     
  1312    492 2010-07-06 22:31:06                               0x00ffcd40 0x069a9000 spoolsv.exe     
  2484    492 2010-07-06 22:39:08                               0x01e584d8 0x07bdc000 rundll32.exe    
   348    340 2010-07-06 22:28:53                               0x03164d40 0x0cd84000 csrss.exe       
   492    384 2010-07-06 22:28:54                               0x040e2030 0x0dcb9000 services.exe    
  1880   1720 2010-07-06 22:38:07                               0x04a291a8 0x0db11000 explorer.exe    
  3064   1488 2010-07-06 22:40:27                               0x04b365b8 0x01961000 VMwareResoluti  
  2512    492 2010-07-06 22:39:09                               0x04dc3bb0 0x0fba2000 schtasks.exe    
  2576    492 2010-07-06 22:39:11                               0x053fe030 0x06e43000 wsqmcons.exe
[snip]
}}}

If a process has previously terminated, the Time exited field will show the exit time. If you want to investigate a hidden process (such as displaying its DLLs), then you'll need physical offset of the EPROCESS object, which is shown in the far left column.

== dlllist ==

To display a process's loaded DLLs, use the dlllist command. It walks the doubly-linked list of LDR_DATA_TABLE_ENTRY structures which is pointed to by the PEB's !InLoadOrderModuleList. 

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp --kpcr=0x8296dc00 dlllist

[snip]

************************************************************************
services.exe pid:    492
Command line : C:\Windows\system32\services.exe

Base         Size         Path
0x00a50000   0x041000     C:\Windows\system32\services.exe
0x778a0000   0x13c000     C:\Windows\SYSTEM32\ntdll.dll
0x779f0000   0x0d4000     C:\Windows\system32\kernel32.dll
0x75ca0000   0x04a000     C:\Windows\system32\KERNELBASE.dll
0x75e40000   0x0ac000     C:\Windows\system32\msvcrt.dll
0x76650000   0x0a1000     C:\Windows\system32\RPCRT4.dll
0x758d0000   0x01a000     C:\Windows\system32\SspiCli.dll
0x759f0000   0x00b000     C:\Windows\system32\profapi.dll
0x75d80000   0x019000     C:\Windows\SYSTEM32\sechost.dll
0x75940000   0x00c000     C:\Windows\system32\CRYPTBASE.dll
0x758c0000   0x00f000     C:\Windows\system32\scext.dll
0x764a0000   0x0c9000     C:\Windows\system32\USER32.dll
0x765b0000   0x04e000     C:\Windows\system32\GDI32.dll
0x76330000   0x00a000     C:\Windows\system32\LPK.dll
[snip]
}}}

To display the DLLs for a specific process instead of all processes, use the -p or --pid filter like this:

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp --kpcr=0x8296dc00 dlllist --pid=492
}}}

To display the DLLs for a process that is hidden or unlinked by a rootkit, first use the psscan2 to get the physical offset of the EPROCESS object and then:

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp --kpcr=0x8296dc00 dlllist --offset=0x04a291a8
}}}

For more ways to list DLLs in a process, see the ldrmodules command.

== dlldump ==

To extract a DLL from a process's memory space and dump it to disk for analysis, use the dlldump command. The syntax is nearly the same as what we've shown for dlllist above. You can:

  * Dump all DLLs from all processes
  * Dump all DLLs from a specific process (with --pid=PID)
  * Dump all DLLs from a hidden/unlinked process (with --offset=OFFSET)

To specify an output directory, use --dump-dir=DIR or -d DIR. You can also supply a regular expression to dump a DLL with a particular pattern in its name. 

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp --kpcr=0x8296dc00 dlldump -r kernel32 -D out
Cannot dump TrustedInstall@kernel32.dll at 779f0000
Cannot dump WmiPrvSE.exe@kernel32.dll at 779f0000
Dumping kernel32.dll, Process: SearchFilterHo, Base: 779f0000 output: module.6bc.da1d760.779f0000.dll
Dumping kernel32.dll, Process: taskhost.exe, Base: 779f0000 output: module.484.546d030.779f0000.dll
Cannot dump dwm.exe@kernel32.dll at 779f0000
Dumping kernel32.dll, Process: explorer.exe, Base: 779f0000 output: module.758.4a291a8.779f0000.dll
Cannot dump wuauclt.exe@kernel32.dll at 779f0000
Dumping kernel32.dll, Process: VMwareTray.exe, Base: 779f0000 output: module.860.fe828d8.779f0000.dll
[snip]
}}}

If the extraction fails, as it did for a few processes above, it probably means that some of the memory pages in that process were not memory resident at the time (due to paging). 

To dump a PE file that doesn't exist in the DLLs list (for example, due to code injection or malicious unlinking), just specify the base address of the PE in process memory:

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp --kpcr=0x8296dc00 dlldump --pid=492 -D out --base=0x00680000
}}}

== files ==

To display the open file handles in a process, use the files command. 

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp --kpcr=0x8296dc00 files -p 4
Volatile Systems Volatility Framework 1.4_rc1
Pid:      4
File   '\\Windows\\System32\\wdi\\LogFiles\\WdiContextLog.etl.001'
File   '\\Windows\\System32\\config\\RegBack\\SECURITY'
File   '\\Windows\\System32\\config\\SECURITY' 
File   '\\Windows\\System32\\config\\RegBack\\DEFAULT'
File   '\\Windows\\System32\\config\\RegBack\\SAM'
File   '\\pagefile.sys'                        
File   '\\Windows\\System32\\config\\SYSTEM'   
File   '\\Windows\\System32\\LogFiles\\WMI\\RtBackup\\EtwRTUBPM.etl'
File   '\\Windows\\System32\\config\\DEFAULT.LOG1'
File   '\\Windows\\System32\\config\\DEFAULT.LOG2'
File   '\\Windows\\System32\\config\\DEFAULT'  
[snip]
}}}

== regobjkeys ==

To display the open registry handles in a process, use the regobjkeys command.

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp --kpcr=0x8296dc00 regobjkeys -p 4
Volatile Systems Volatility Framework 1.4_rc1
Pid:      4
Key    MACHINE\SYSTEM\CONTROLSET001\CONTROL\HIVELIST                        
Key    MACHINE\SYSTEM\CONTROLSET001\CONTROL\PRODUCTOPTIONS
Key    MACHINE\SYSTEM\CONTROLSET001\CONTROL\SESSION MANAGER\MEMORY MANAGEMENT\PREFETCHPARAMETERS
Key    MACHINE\SYSTEM\SETUP                    
Key    MACHINE\HARDWARE\DESCRIPTION\SYSTEM\MULTIFUNCTIONADAPTER
Key    MACHINE\SYSTEM\CONTROLSET001            
Key    MACHINE\SYSTEM\CONTROLSET001\ENUM       
Key    MACHINE\SYSTEM\CONTROLSET001\CONTROL\CLASS
Key    MACHINE\SYSTEM\CONTROLSET001\SERVICES   
Key    MACHINE\SYSTEM\CONTROLSET001\CONTROL\WMI\SECURITY
Key    MACHINE\SYSTEM\CONTROLSET001\CONTROL\LSA
[snip]
}}}

== getsids ==

To view the SIDs (Security Identifiers) associated with a process, use the getsids command. Among other things, this can help you identify processes which have maliciously elevated privileges. 

For more information, see BDG's [http://moyix.blogspot.com/2008/08/linking-processes-to-users.html Linking Processes To Users].

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp --kpcr=0x8296dc00 getsids 
Volatile Systems Volatility Framework 1.4_rc1
System (4): S-1-5-18 (Local System)
System (4): S-1-5-32-544 (Administrators)
System (4): S-1-1-0 (Everyone)
System (4): S-1-5-11 (Authenticated Users)
System (4): S-1-16-16384 (System Mandatory Level)
smss.exe (252): S-1-5-18 (Local System)
smss.exe (252): S-1-5-32-544 (Administrators)
smss.exe (252): S-1-1-0 (Everyone)
smss.exe (252): S-1-5-11 (Authenticated Users)
smss.exe (252): S-1-16-16384 (System Mandatory Level)
[snip]
}}}

== verinfo ==

To display the version information embedded in PE files, use the verinfo command. Not all PE files have version information, and many malware authors forge it to include false data, but nonetheless this command can be very helpful with identifying binaries and for making correlations with other files. 

This command supports filtering by process ID, regular expression, and EPROCESS offset. 

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp --kpcr=0x8296dc00 verinfo
[snip]

C:\Windows\system32\CRYPTBASE.dll
C:\Windows\system32\winlogon.exe
  File version    : 6.1.7600.16447
  Product version : 6.1.7600.16447
  Flags           : 
  OS              : Windows NT
  File Type       : Application
  File Date       : 
  CompanyName : Microsoft Corporation
  FileDescription : Windows Logon Application
  FileVersion : 6.1.7600.16447 (win7_gdr.091027-1503)
  InternalName : winlogon
  LegalCopyright : \xa9 Microsoft Corporation. All rights reserved.
  OriginalFilename : WINLOGON.EXE
  ProductName : Microsoft\xae Windows\xae Operating System
  ProductVersion : 6.1.7600.16447

[snip] 

C:\Windows\System32\ntlanman.dll
  File version    : 6.1.7600.16385
  Product version : 6.1.7600.16385
  Flags           : 
  OS              : Windows NT
  File Type       : Dynamic Link Library
  File Date       : 
  CompanyName : Microsoft Corporation
  FileDescription : Microsoft\xae Lan Manager
  FileVersion : 6.1.7600.16385 (win7_rtm.090713-1255)
  InternalName : ntlanman.dll
  LegalCopyright : \xa9 Microsoft Corporation. All rights reserved.
  OriginalFilename : ntlanman.dll
  ProductName : Microsoft\xae Windows\xae Operating System
  ProductVersion : 6.1.7600.16385

[snip]
}}}

You can also reference the verinfo plugin for an example of how to parse PE headers in memory images, if you happen to be looking for other information such as digital signatures, resources, import and export tables, etc. 

= Process Memory =

== memmap ==

For a brief inspection of the addressable memory pages in a process, use the memmap command. 

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp --kpcr=0x8296dc00 -p 1880 memmap 
explorer.exe pid:   1880
Virtual      Physical     Size        
0x0000010000 0x00075cb000 0x000000001000
0x0000021000 0x0009c2c000 0x000000001000
0x0000030000 0x0002adf000 0x000000001000
0x0000031000 0x0000d99000 0x000000001000
0x0000032000 0x000583a000 0x000000001000
0x0000040000 0x000a25b000 0x000000001000
0x0000041000 0x00044d6000 0x000000001000
0x0000050000 0x00099ee000 0x000000001000
0x0000060000 0x000b155000 0x000000001000
[snip]
}}}

== memdump ==

To extract all data from the various memory segments in a process and dump them to a single file, use the memdump command. 

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp --kpcr=0x8296dc00 -p 1880 memdump -D memory/
Volatile Systems Volatility Framework 1.4_rc1
************************************************************************
Writing explorer.exe [  1880] to 1880.dmp

$ ls -alh memory/1880.dmp 
-rw-r--r--  1 User  staff   140M Feb  8 15:13 memory/1880.dmp
}}}

== procmemdump ==

To dump a process's executable (including the slack space), use the procmemdump command. Optionally, pass the --unsafe or -u flags to bypass certain sanity checks used when parsing the PE header. For example, some malware will intentionally forge size fields in the PE header so that memory dumping tools fail. 

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp --kpcr=0x8296dc00 -p 1880 procmemdump -D memory/
Volatile Systems Volatility Framework 1.4_rc1
************************************************************************
Dumping explorer.exe, pid:   1880 output: executable.1880.exe

$ file memory/executable.1880.exe 
memory/executable.1880.exe: PE32 executable for MS Windows (GUI) Intel 80386 32-bit
}}}

== procexedump ==

To dump a process's executable (*not* including the slack space), use the procexedump command. The syntax is identical to procmemdump.

== vadwalk ==

To briefly inspect a process's VAD nodes, use the vadwalk command. For more information on the VAD, see BDG's [http://www.dfrws.org/2007/proceedings/p62-dolan-gavitt.pdf The VAD Tree: A Process-Eye View of Physical Memory].

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp --kpcr=0x8296dc00 -p 1880 vadwalk
Volatile Systems Volatility Framework 1.4_rc1
************************************************************************
Pid:   1880
Address  Parent   Left     Right    Start    End      Tag  Flags
8d5487b8 00000000 8d6a4a20 8d7d5ef8 6ce80000 6ceeefff Vad 
8d6a4a20 00000000 8d57ed70 84e4e7f8 02e30000 02e31fff VadS
8d57ed70 8d6a4a20 8d6cffb8 8d7c5c20 01c90000 01e8ffff Vadm
8d6cffb8 00000000 8d760e58 8d457268 00a20000 00ca0fff Vadm
8d760e58 00000000 84d529c0 84d2a1b8 00090000 000cffff VadS
84d529c0 00000000 84e689a0 8d782428 00040000 00041fff Vad 
84e689a0 84d529c0 84d52708 83efff78 00020000 00021fff Vad 
84d52708 84e689a0 00000000 00000000 00010000 0001ffff Vad 
83efff78 84e689a0 00000000 00000000 00030000 00033fff Vad 
[snip]
}}}

== vadtree ==

To display the VAD nodes in a visual tree form, use the vadtree command. 

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp --kpcr=0x8296dc00 -p 1880 vadtree
Volatile Systems Volatility Framework 1.4_rc1
************************************************************************
Pid:   1880
6ce80000 - 6ceeefff
02e30000 - 02e31fff
 01c90000 - 01e8ffff
00a20000 - 00ca0fff
00090000 - 000cffff
00040000 - 00041fff
 00020000 - 00021fff
  00010000 - 0001ffff
}}}

If you want to view the balanced binary tree in Graphviz format, use the dot output rendering:

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp --kpcr=0x8296dc00 -p 1880 vadtree --output=dot --output-file=graph.dot
}}}

Now you can open graph.dot in any Graphviz-compatible viewer. 

== vadinfo ==

The vadinfo command displays extended information about a process's VAD nodes. In particular, it shows:

  * The address of the MMVAD structure in kernel memory
  * The starting and ending virtual addresses
  * The VAD Tag 
  * The memory protection constant (permissions)
  * The name of the memory mapped file (if one exists)

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp --kpcr=0x8296dc00 -p 1880 vadinfo

VAD node @8d570798 Start 05330000 End 0536ffff Tag VadS
Flags: PrivateMemory
Commit Charge: 18 Protection: 4

VAD node @8d6d78a0 Start 05850000 End 0588ffff Tag VadS
Flags: PrivateMemory
Commit Charge: 16 Protection: 4

VAD node @84f40530 Start 6c750000 End 6c756fff Tag Vad 
Flags: UserPhysicalPages
Commit Charge: 2 Protection: 7
ControlArea @84d501e8 Segment 99e28118
Dereference list: Flink 00000000, Blink 00000000
NumberOfSectionReferences:          0 NumberOfPfnReferences:           1
NumberOfMappedViews:                1 NumberOfUserReferences:          1
WaitingForDeletion Event:  00000000
Flags: File, Image
FileObject @84e8e910 FileBuffer @ 9c52c7b0          , Name: \Windows\System32\msiltcfg.dll
First prototype PTE: 99e28144 Last contiguous PTE: fffffffc
Flags2: Inherit
File offset: 00000000

[snip]
}}}

== vaddump ==

To extract the data contained within each VAD segment, use the vaddump command. This is similar to memdump, except the data ends up in separate files, named according to the address in process memory where the data was found. 

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp --kpcr=0x8296dc00 vaddump -D vads
Volatile Systems Volatility Framework 1.4_rc1
Pid:      4
************************************************************************
Pid:    252
************************************************************************
Pid:    348
************************************************************************
Pid:    384
************************************************************************
Pid:    396
************************************************************************
Pid:    424
[snip]

$ ls -alh vads/
-rw-r--r--    1 User  staff   128K Feb  8 15:29 System.a2d960.00120000-0013ffff.dmp
-rw-r--r--    1 User  staff   128K Feb  8 15:29 System.a2d960.00140000-0015ffff.dmp
-rw-r--r--    1 User  staff   128K Feb  8 15:29 System.a2d960.00160000-0017ffff.dmp
-rw-r--r--    1 User  staff   128K Feb  8 15:29 System.a2d960.00180000-0019ffff.dmp
-rw-r--r--    1 User  staff   1.2M Feb  8 15:29 System.a2d960.778a0000-779dbfff.dmp
-rw-r--r--    1 User  staff   1.0M Feb  8 15:29 csrss.exe.3164d40.00000000-000fffff.dmp
-rw-r--r--    1 User  staff   412K Feb  8 15:29 csrss.exe.3164d40.00100000-00166fff.dmp
-rw-r--r--    1 User  staff   4.0K Feb  8 15:29 csrss.exe.3164d40.00170000-00170fff.dmp
-rw-r--r--    1 User  staff   8.0K Feb  8 15:29 csrss.exe.3164d40.00180000-00181fff.dmp
-rw-r--r--    1 User  staff   4.0K Feb  8 15:29 csrss.exe.3164d40.00190000-00190fff.dmp
[snip]
}}}

The files are named like this:

!ProcessName.!PhysicalOffset.!StartingVPN.!EndingVPN.dmp

The reason the !PhysicalOffset field exists is so you can distinguish between two processes with the same name. 

= Kernel Memory and Objects =

== modules ==

To view the list of kernel drivers loaded on the system, use the modules command. This walks the doubly-linked list of LDR_DATA_TABLE_ENTRY structures pointed to by !PsLoadedModuleList. It cannot find hidden/unlinked kernel drivers.

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp modules
Volatile Systems Volatility Framework 1.4_rc1
File                                               Base         Size     Name
\SystemRoot\system32\ntoskrnl.exe                  0x008284c000 0x400000 ntoskrnl.exe
\SystemRoot\system32\halmacpi.dll                  0x0082815000 0x037000 hal.dll
\SystemRoot\system32\kdcom.dll                     0x0080bcc000 0x008000 kdcom.dll
\SystemRoot\system32\mcupdate_GenuineIntel.dll     0x0085c2d000 0x078000 mcupdate.dll
\SystemRoot\system32\PSHED.dll                     0x0085ca5000 0x011000 PSHED.dll
\SystemRoot\system32\BOOTVID.dll                   0x0085cb6000 0x008000 BOOTVID.dll
\SystemRoot\system32\CLFS.SYS                      0x0085cbe000 0x042000 CLFS.SYS
\SystemRoot\system32\CI.dll                        0x0085d00000 0x0ab000 CI.dll
\SystemRoot\system32\drivers\Wdf01000.sys          0x0085dab000 0x071000 Wdf01000.sys
\SystemRoot\system32\drivers\WDFLDR.SYS            0x0085e1c000 0x00e000 WDFLDR.SYS
\SystemRoot\system32\DRIVERS\ACPI.sys              0x0085e2a000 0x048000 ACPI.sys
\SystemRoot\system32\DRIVERS\WMILIB.SYS            0x0085e72000 0x009000 WMILIB.SYS
[snip] 
}}}

== modscan2 ==

To scan physical memory for kernel modules, use the modscan2 command. This can pick up previously unloaded drivers and drivers that have been hidden/unlinked by rootkits. 

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp modscan2
Volatile Systems Volatility Framework 1.4_rc1
File                                               Base         Size     Name
'\\SystemRoot\\System32\\Drivers\\spldr.sys'       0x00865c9000 0x008000 'spldr.sys'
'\\SystemRoot\\system32\\DRIVERS\\volsnap.sys'     0x008658a000 0x03f000 'volsnap.sys'
'\\SystemRoot\\system32\\DRIVERS\\vmstorfl.sys'    0x0086581000 0x009000 'vmstorfl.sys'
'\\SystemRoot\\System32\\drivers\\fwpkclnt.sys'    0x0086550000 0x031000 'fwpkclnt.sys'
'\\SystemRoot\\System32\\drivers\\tcpip.sys'       0x0086407000 0x149000 'tcpip.sys'
'\\SystemRoot\\System32\\Drivers\\ksecpkg.sys'     0x0086333000 0x025000 'ksecpkg.sys'
'\\SystemRoot\\system32\\drivers\\NETIO.SYS'       0x00862f5000 0x03e000 'NETIO.SYS'
'\\SystemRoot\\system32\\drivers\\ndis.sys'        0x008623e000 0x0b7000 'ndis.sys'
'\\SystemRoot\\System32\\Drivers\\Fs_Rec.sys'      0x0086235000 0x009000 'Fs_Rec.sys'
'\\SystemRoot\\System32\\drivers\\pcw.sys'         0x0086227000 0x00e000 'pcw.sys'
'\\SystemRoot\\System32\\Drivers\\cng.sys'         0x00861ca000 0x05d000 'cng.sys'
'\\SystemRoot\\System32\\Drivers\\ksecdd.sys'      0x00861b7000 0x013000 'ksecdd.sys'
[snip]
}}}

== moddump ==

To extract a kernel driver to a file, use the moddump command. It supports filtering by regular expression (case sensitive or not) and by physical offsets. To dump all drivers, don't use any command-line filters. For example:

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp moddump -D mods/
Volatile Systems Volatility Framework 1.4_rc1
Dumping ntoskrnl.exe, Base: 8284c000 output: driver.8284c000.sys
Dumping hal.dll, Base: 82815000 output: driver.82815000.sys
Dumping fwpkclnt.sys, Base: 86550000 output: driver.86550000.sys
Dumping kdcom.dll, Base: 80bcc000 output: driver.80bcc000.sys
Dumping NDProxy.SYS, Base: 8c7ec000 output: driver.8c7ec000.sys
Dumping CLFS.SYS, Base: 85cbe000 output: driver.85cbe000.sys
Dumping luafv.sys, Base: 8840c000 output: driver.8840c000.sys
Dumping peauth.sys, Base: 8857c000 output: driver.8857c000.sys
[snip]
}}}

== ssdt ==

To list the functions in the Native and GUI SSDTs, use the ssdt command. This displays the index, function name, and owning driver for each entry in the SSDT. Please note the following very important facts:

  * Windows has 4 SSDTs by default (you can add more with !KeAddSystemServiceTable), but only 2 of them are used - one for Native functions in the NT module, and one for GUI functions in the win32k.sys module. 
  * There are multiple ways to locate the SSDTs in memory. Most tools do it by finding the exported !KeServiceDescriptorTable symbol in the NT module, but this is not the way Volatility works. Volatility scans for ETHREAD objects (see the thrdscan2 command) and gathers all unique ETHREAD.Tcb.!ServiceTable pointers. This method is more robust and complete, because it can detect when rootkits make copies of the existing SSDTs and assign them to particular threads. Also see the ssdt_by_threads command. 
  * The order and total number of functions in the SSDT differs across operating system versions. Thus, Volatility stores the information in a per-profile (OS) manner. 

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp ssdt 
Volatile Systems Volatility Framework 1.4_rc1
Gathering all referenced SSDTs from KTHREADs...
Finding appropriate address space for tables...
SSDT[0] at 828a8634 with 401 entries
  Entry 0x0000: 0x82a8530e (NtAcceptConnectPort) owned by ntoskrnl.exe
  Entry 0x0001: 0x828d6774 (NtAccessCheck) owned by ntoskrnl.exe
  Entry 0x0002: 0x82abd460 (NtAccessCheckAndAuditAlarm) owned by ntoskrnl.exe
  Entry 0x0003: 0x82901dea (NtAccessCheckByType) owned by ntoskrnl.exe
  Entry 0x0004: 0x82a9f99a (NtAccessCheckByTypeAndAuditAlarm) owned by ntoskrnl.exe
  Entry 0x0005: 0x8294145a (NtAccessCheckByTypeResultList) owned by ntoskrnl.exe

[snip]

SSDT[1] at 977a5000 with 825 entries
  Entry 0x1000: 0x9772eb34 (NtGdiAbortDoc) owned by win32k.sys
  Entry 0x1001: 0x9774752e (NtGdiAbortPath) owned by win32k.sys
  Entry 0x1002: 0x975adc1a (NtGdiAddFontResourceW) owned by win32k.sys
  Entry 0x1003: 0x9773e5ae (NtGdiAddRemoteFontToDC) owned by win32k.sys
  Entry 0x1004: 0x97748c89 (NtGdiAddFontMemResourceEx) owned by win32k.sys
  Entry 0x1005: 0x9772f351 (NtGdiRemoveMergeFont) owned by win32k.sys
  Entry 0x1006: 0x9772f3e5 (NtGdiAddRemoteMMInstanceToDC) owned by win32k.sys
  Entry 0x1007: 0x976545cc (NtGdiAlphaBlend) owned by win32k.sys

[snip]
}}}

To filter all functions which point to ntoskrnl.exe and win32k.sys, you can use egrep on command-line. This will only show hooked SSDT functions. 

== driverscan ==

To scan for DRIVER_OBJECTs in physical memory, use the driverscan command. This is another way to locate kernel modules, although not all kernel modules have an associated DRIVER_OBJECT. The DRIVER_OBJECT is what contains the 28 IRP (Major Function) tables, thus the driverirp command is based on the methodology used by driverscan. 

For more information, see Andreas Schuster's [http://computer.forensikblog.de/en/2009/04/scanning_for_drivers.html Scanning for Drivers].

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp driverscan 
Volatile Systems Volatility Framework 1.4_rc1
Phys.Addr. Obj Type   #Ptr #Hnd Start        Size Service key          Name
0x007f1300 0x0000001a   67    0 0x85e2a000 294912 'ACPI'               'ACPI'       '\\Driver\\ACPI'
0x007f1b30 0x0000001a    3    0 0x85dab000 462848 'Wdf01000'           'Wdf01000'   '\\Driver\\Wdf01000'
0x00c630d8 0x0000001a    3    0 0x88427000  65536 'lltdio'             'lltdio'     '\\Driver\\lltdio'
0x00cb0108 0x0000001a    3    0 0x88437000  77824 'rspndr'             'rspndr'     '\\Driver\\rspndr'
0x00dedd38 0x0000001a    4    0 0x8844a000 544768 'HTTP'               'HTTP'       '\\Driver\\HTTP'
0x05533b88 0x0000001a    3    0 0x88573000  28672 'Parvdm'             'Parvdm'     '\\Driver\\Parvdm'
0x0ad99af8 0x0000001a    5    0 0x8c400000  94208 'usbccgp'            'usbccgp'    '\\Driver\\usbccgp'
0x0bd46650 0x0000001a    3    0 0x8857a000   7680 'VMMEMCTL'           'VMMEMCTL'   '\\Driver\\VMMEMCTL'
0x0c8b5400 0x0000001a    2    0 0x8840c000 110592 'luafv'              'luafv'      '\\FileSystem\\luafv'
0x0d747c18 0x0000001a    3    0 0x884cf000 102400 'bowser'             'bowser'     '\\FileSystem\\bowser'
0x0d98cc60 0x0000001a    3    0 0x8864b000 323584 'srv2'               'srv2'       '\\FileSystem\\srv2'
[snip]
}}}

== filescan ==

To scan physical memory for FILE_OBJECTs, use the filescan command. This will find open files even if a rootkit is hiding the files on disk and if the rootkit hooks some API functions to hide the open handles on a live system. The output shows the physical offset of the FILE_OBJECT, file name, number of pointers to the object, number of handles to the object, and the effective permissions granted to the object. 

For more information, see Andreas Schuster's [http://computer.forensikblog.de/en/2009/04/scanning_for_file_objects.html Scanning for File Objects] and [http://computer.forensikblog.de/en/2009/04/linking_file_objects_to_processes.html Linking File Objects To Processes]. 

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp filescan
Volatile Systems Volatility Framework 1.4_rc1
Phys.Addr. Obj Type   #Ptr #Hnd Access Name
0x007b1020 0x0000001c   17    0 RW-rwd '\\$Directory'
0x007b1280 0x0000001c    8    1 R--r-d '\\Windows\\System32\\en-US\\gpsvc.dll.mui'
0x00921bb8 0x0000001c    2    0 R--r-d '\\Windows\\System32\\msftedit.dll'
0x00be5950 0x0000001c    1    1 R--rw- '\\Windows\\System32'
0x00be76b8 0x0000001c    7    0 R--r-- '\\Windows\\Fonts\\marlett.ttf'
0x00bf2370 0x0000001c    8    0 R--r-d '\\Windows\\System32\\sscore.dll'
0x00bf2520 0x0000001c    9    1 R--r-d '\\Windows\\System32\\en-US\\sysmain.dll.mui'
0x00c23a68 0x0000001c    3    0 R--r-d '\\Windows\\System32\\wkssvc.dll'
0x00c23db0 0x0000001c    1    1 ------ '\\srvsvc'
0x00c5a910 0x0000001c   17    0 RW-rwd '\\$Directory'
0x00c5ab10 0x0000001c    5    0 R--r-d '\\Windows\\System32\\w32time.dll'
0x00c64228 0x0000001c   16    1 RW-r-- '\\Windows\\System32\\winevt\\Logs\\Microsoft-Windows-GroupPolicy%4Operational.evtx'
0x00c64610 0x0000001c    8    0 R--r-d '\\Windows\\System32\\RpcRtRemote.dll'
0x00c648a0 0x0000001c    6    0 R--r-d '\\Windows\\System32\\ntlanman.dll'
0x00c70c70 0x0000001c    1    1 ------ '\\wkssvc'
0x00ca3530 0x0000001c    4    0 ------ '\\Windows\\System32\\locale.nls'
0x00ca3ea8 0x0000001c    3    0 R--r-d '\\Windows\\System32\\wiarpc.dll'
0x00ca4330 0x0000001c    3    0 R--r-d '\\Windows\\System32\\Sens.dll'
0x00ca4b48 0x0000001c    2    0 R--r-d '\\Windows\\System32\\ktmw32.dll'
0x00ca4c00 0x0000001c    6    0 R--r-d '\\Windows\\System32\\schedsvc.dll'
0x00cad020 0x0000001c    1    1 R--r-- '\\Windows\\Registration\\R000000000006.clb'
0x00cadc28 0x0000001c    1    1 ------ '\\wkssvc'
0x00cade78 0x0000001c    1    1 ------ '\\wkssvc'
[snip]
}}}

== mutantscan ==

To scan physical memory for KMUTANT objects, use the mutantscan command. By default, it displays all objects, but you can pass -s or --silent to only show named mutexes. The CID column contains the process ID and thread ID of the mutex owner if one exists.

For more information, see Andreas Schuster's [http://computer.forensikblog.de/en/2009/04/searching_for_mutants.html Searching for Mutants].

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp mutantscan -s
Volatile Systems Volatility Framework 1.4_rc1
Phys.Addr. Obj Type   #Ptr #Hnd Signal Thread     CID        Name
0x07f955a0 0x0000000e    2    1      1 0x00000000            'TapiSrv_Perf_Library_Lock_PID_5d0'
0x081b5ce8 0x0000000e    2    1      1 0x00000000            'WininetProxyRegistryMutex'
0x08ffccc8 0x0000000e    3    2      1 0x00000000            'ZoneAttributeCacheCounterMutex'
0x099f21f8 0x0000000e    2    1      1 0x00000000            '_!MSFTHISTORY!_'
0x099f2e58 0x0000000e    2    1      1 0x00000000            'ZonesCacheCounterMutex'
0x09aa83a0 0x0000000e    2    1      1 0x00000000            'ZonesLockedCacheCounterMutex'
0x09aa8bd0 0x0000000e    2    1      1 0x00000000            'ZonesCacheCounterMutex'
0x09d06c18 0x0000000e    2    1      1 0x00000000            'VMwareGuestDnDDataMutex'
0x0afe45d8 0x0000000e    2    1      1 0x00000000            '__?_c:_programdata_microsoft_rac_temp_sql4c79.tmp:x'
0x0b6ea040 0x0000000e    2    1      0 0x83ecd030 2520:2616  'F659A567-8ACB-4E4A-92A7-5C2DD1884F72'
0x0be081e8 0x0000000e    2    1      1 0x00000000            'BITS_Perf_Library_Lock_PID_5d0'
[snip]
}}}

== thrdscan2 ==

To scan for ETHREAD objects in physical memory, use the thrdscan2 command. Since an ETHREAD contains fields that identify its parent process, you can use this technique to find hidden processes. One such use case is documented in the orphanthreads command. 

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp thrdscan2
Volatile Systems Volatility Framework 1.4_rc1
PID    TID    Create Time               Exit Time                 Offset    
------ ------ ------------------------- ------------------------- ----------
   876   2424                                                     0x006960c8
   348    480                                                     0x007b1538
  1344   1964                                                     0x00c62030
  1140   1404                                                     0x00c62d48
  1312   1224                                                     0x00c64ad8
   876   1236                                                     0x00ca4cc8
   840   1800                           2010-07-06 22:33:47       0x00cea150
  1344   1352                                                     0x00d62bb8
  1140   1440                                                     0x00eb4d48
  1920    800                                                     0x00ebf030
   384    388                                                     0x00ebf538
   876   1320                           2010-07-06 22:38:33       0x00ebf978
  1880   2372                                                     0x00eef548
   876   1164                                                     0x00ef8030
[snip]
}}}

= Networking =

== connections ==

To view the active connections, use the connections command. This walks the singly-linked list of connection structures pointed to by a non-exported symbol in the tcpip.sys module. This command is for Windows XP only. 

{{{
$ python volatility.py --profile=WinXPSP3x86 -f silentbanker.vmem connections
Volatile Systems Volatility Framework 1.4_rc1
Local Address             Remote Address            Pid   
192.168.128.128:1299      207.46.216.54:80            1876
192.168.128.128:1293      8.12.206.126:80             1876
192.168.128.128:1276      207.68.173.76:80            1876
192.168.128.128:1285      208.59.255.160:80           1876
192.168.128.128:1274      65.55.12.249:80             1876
192.168.128.128:1275      65.54.77.76:80              1876
192.168.128.128:1294      65.55.15.241:80             1876
192.168.128.128:1288      65.55.149.122:80            1876
192.168.128.128:1281      199.93.33.126:80            1876
[snip]
}}}

== connscan2 ==

To find connection structures using pool tag scanning, use the connscan2 command. This can find artifacts from previous connections that have since been terminated. In the output below, you'll notice some fields have been partially overwritten, but some of the information is still accurate. Thus, while it may find false positives sometimes, you also get the benefit of detecting as much information as possible. This command is for Windows XP only. 

{{{
$ python volatility.py --profile=WinXPSP3x86 -f silentbanker.vmem connscan2
Volatile Systems Volatility Framework 1.4_rc1
Local Address             Remote Address            Pid   
------------------------- ------------------------- ------ 
192.168.128.128:1295      65.55.15.125:80             1876
192.168.128.128:1297      209.62.188.19:80            1876
192.168.128.128:1298      209.62.176.153:80           1876
192.168.128.128:1282      199.93.33.126:80            1876
192.168.128.128:1281      199.93.33.126:80            1876
192.168.128.128:1283      66.235.138.18:80            1876
192.168.128.128:1284      65.55.239.189:80            1876
192.168.128.128:1274      65.55.12.249:80             1876
192.168.128.128:1275      65.54.77.76:80              1876
192.168.128.128:1277      199.93.33.126:80            1876
192.168.128.128:1280      8.12.206.126:80             1876
115.37.0.0:28526          78.101.120.116:67         1952671086
116.101.73.112:25714      82.101.109.111:16740      1953723237
9.0.0.0:25441             80.105.100.116:19567      1919897708
[snip]
}}}

== sockets ==

To detect listening sockets for any protocol (TCP, UDP, RAW, etc), use the sockets command. This walks a singly-linked list of socket structures which is pointed to by a non-exported symbol in the tcpip.sys module. This command is for Windows XP only. 

{{{
$ python volatility.py --profile=WinXPSP3x86 -f silentbanker.vmem sockets
Volatile Systems Volatility Framework 1.4_rc1
Pid    Port   Proto  Create Time               
  1876   1274      6 2009-02-18 06:55:23       
  1876   1282      6 2009-02-18 06:55:24       
  1156   1900     17 2008-12-11 20:51:52       
  1876   1273     17 2009-02-18 06:55:20       
   740    500     17 2008-09-18 05:33:19       
     4    139      6 2008-12-11 20:51:51       
  1876   1290      6 2009-02-18 06:55:26       
  1876   1294      6 2009-02-18 06:55:29
[snip]
}}}

== sockscan ==

To find socket structures using pool tag scanning, use the sockscan command. As with connscan2, this can pick up residual data and artifacts from previous sockets, and it only applies to Windows XP. 

{{{
$ python volatility.py --profile=WinXPSP3x86 -f silentbanker.vmem sockscan
Volatile Systems Volatility Framework 1.4_rc1
PID    Port   Proto  Create Time                Offset 
------ ------ ------ -------------------------- ----------
  1876   1297      6 2009-02-18 06:55:30        0x0161c1d8
  1876   1294      6 2009-02-18 06:55:29        0x0161fbc0
  1876   1295      6 2009-02-18 06:55:29        0x01622e98
  1876   1299      6 2009-02-18 06:55:30        0x0162ac38
  1876   1293      6 2009-02-18 06:55:28        0x0162b5b8
  1876   1273     17 2009-02-18 06:55:20        0x016523a8
  1876   1279      6 2009-02-18 06:55:24        0x01668c68
     4    137     17 2008-12-11 20:51:51        0x01677388
  1876   1277      6 2009-02-18 06:55:24        0x01680e98
[snip]
}}}

== netscan ==

To scan for network artifacts in Windows Vista and Windows 7 memory dumps, use the netscan command. This finds TCP endpoints, TCP listeners, UDP endpoints, and UDP listeners. It distinguishes between IPv4 and IPv6, prints the local and remote IP (if applicable), the local and remote port (if applicable), the time when the socket was bound or when the connection was established, and the current state (for TCP connections only). 

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp netscan 
Volatile Systems Volatility Framework 1.4_rc1
Offset     Proto    Local Address                  Foreign Address      State            Pid      Owner          Created
0xca3008   TCPv4    192.168.181.133:139            0.0.0.0:0            LISTENING        4        System         1970-01-01 00:00:00 
0x3027008  TCPv4    0.0.0.0:49155                  0.0.0.0:0            LISTENING        876      svchost.exe    1970-01-01 00:00:00 
0x3027008  TCPv6    :::49155                       :::0                 LISTENING        876      svchost.exe    1970-01-01 00:00:00 
0x5ac5c80  TCPv4    0.0.0.0:49153                  0.0.0.0:0            LISTENING        728      svchost.exe    1970-01-01 00:00:00 
0x5ac5c80  TCPv6    :::49153                       :::0                 LISTENING        728      svchost.exe    1970-01-01 00:00:00 
0xbfe1208  TCPv4    0.0.0.0:49152                  0.0.0.0:0            LISTENING        384      wininit.exe    1970-01-01 00:00:00 
0xbfe1208  TCPv6    :::49152                       :::0                 LISTENING        384      wininit.exe    1970-01-01 00:00:00 
0xbfe1648  TCPv4    0.0.0.0:49152                  0.0.0.0:0            LISTENING        384      wininit.exe    1970-01-01 00:00:00 
0xc1fad48  TCPv4    0.0.0.0:49153                  0.0.0.0:0            LISTENING        728      svchost.exe    1970-01-01 00:00:00 
0xc5ae148  TCPv4    0.0.0.0:135                    0.0.0.0:0            LISTENING        680      svchost.exe    1970-01-01 00:00:00 
0xc6f5bb0  TCPv4    0.0.0.0:135                    0.0.0.0:0            LISTENING        680      svchost.exe    1970-01-01 00:00:00 
0xc6f5bb0  TCPv6    :::135                         :::0                 LISTENING        680      svchost.exe    1970-01-01 00:00:00 
0xd816270  TCPv4    0.0.0.0:445                    0.0.0.0:0            LISTENING        4        System         1970-01-01 00:00:00 
0xd816270  TCPv6    :::445                         :::0                 LISTENING        4        System         1970-01-01 00:00:00 
0xdc5a368  TCPv4    0.0.0.0:49156                  0.0.0.0:0            LISTENING        492      services.exe   1970-01-01 00:00:00 
0xde59008  TCPv4    0.0.0.0:49156                  0.0.0.0:0            LISTENING        492      services.exe   1970-01-01 00:00:00 
0xde59008  TCPv6    :::49156                       :::0                 LISTENING        492      services.exe   1970-01-01 00:00:00 
0xed29808  TCPv4    0.0.0.0:49155                  0.0.0.0:0            LISTENING        876      svchost.exe    1970-01-01 00:00:00 
0xee49450  TCPv4    0.0.0.0:49154                  0.0.0.0:0            LISTENING        500      lsass.exe      1970-01-01 00:00:00 
0xee52d98  TCPv4    0.0.0.0:49154                  0.0.0.0:0            LISTENING        500      lsass.exe      1970-01-01 00:00:00 
0xee52d98  TCPv6    :::49154                       :::0                 LISTENING        500      lsass.exe      1970-01-01 00:00:00 
0x4b5c008  TCPv4    0.0.0.0:49170                  65.54.89.134:80      CLOSED           876      svchost.exe    1970-01-01 00:00:00 
0x9b3ca30  TCPv4    192.168.181.133:49167          192.168.181.2:80     CLOSED           876      svchost.exe    1970-01-01 00:00:00 
0xee8e0c8  TCPv4    0.0.0.0:49159                  65.54.89.134:80      CLOSED           876      svchost.exe    1970-01-01 00:00:00 
0xf78d468  TCPv4    0.0.0.0:49164                  65.54.89.135:80      CLOSED           876      svchost.exe    1970-01-01 00:00:00 
0x3165c8   UDPv4    0.0.0.0:0                      *:*                                   1056     svchost.exe    2010-07-06 22:40:01 
0x3165c8   UDPv6    :::0                           *:*                                   1056     svchost.exe    2010-07-06 22:40:01 
0xea9868   UDPv4    127.0.0.1:1900                 *:*                                   1920     svchost.exe    2010-07-06 22:33:18 
0x12d6738  UDPv4    0.0.0.0:0                      *:*                                   1140     svchost.exe    2010-07-06 22:31:23 
0x12d6738  UDPv6    :::0                           *:*                                   1140     svchost.exe    2010-07-06 22:31:23
[snip]
}}}

= Registry =

== hivescan ==
== hivelist ==
== printkey ==
== hivedump ==
== hashdump ==
== lsadump ==

= Crash Dumps, Hibernation, and Conversion =

== crashdump ==
== crashinfo ==
== hibdump ==
== hibinfo ==
== imagecopy ==

= Malware and Rootkits =

== malfind ==
== svcscan ==
== ldrmodules ==
== impscan ==
== apihooks ==
== idt ==
== orphanthreads ==
== notifyroutines ==
== driverirp ==
== csrpslist ==
== ssdt_ex ==
== ssdt_by_threads ==

= Miscellaneous =

== strings ==
== volshell ==
== bioskbd ==
== inspectcache ==
== patcher ==
== testsuite ==