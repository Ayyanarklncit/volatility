#summary Example usage cases and output for Volatility commands
#labels Featured

This page contains 

<wiki:toc max_depth="3" />

= Image Identification =

== imageinfo ==

If you don't know what type of system your image came from, use the imageinfo command. 

{{{
$ python volatility.py -f win7.dmp imageinfo
Volatile Systems Volatility Framework 1.4_rc1
Determining profile based on KDBG search...
             Suggested Profile : Win7SP0x86
                     AS Layer1 : JKIA32PagedMemory (Kernel AS)
                     AS Layer2 : FileAddressSpace (/Users/M/Desktop/win7.dmp)
                      PAE type : No PAE
                           DTB : 0x185000
                          KDBG : 0x8296cbe8
                          KPCR : 0x8296dc00
             KUSER_SHARED_DATA : 0xffdf0000
           Image date and time : 2010-07-06 22:40:28 
     Image local date and time : 2010-07-06 22:40:28 
                    Image Type : 
}}}

Among other things, the imageinfo output tells you the suggested profile that you should pass as the parameter to --profile=PROFILE. It also tells you the address of the KPCR and KDBG (short for `_KDDEBUGGER_DATA64`).  Plugins automatically scan for these values when they need them, however you can specify them directly for any plugin by providing --kpcr=ADDRESS or --kdbg=ADDRESS. By supplying the profile and KDBG (or failing that KPCR) to other Volatility commands, you'll get the most accurate and fastest results possible.

== datetime ==

Use datetime to get the date and time information from when the memory image was acquired. 

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp datetime
Volatile Systems Volatility Framework 1.4_rc1
Image date and time       : 2010-07-06 22:40:28 
Image local date and time : 2010-07-06 22:40:28
}}}

== kdbgscan ==

Use this command to scan for potential KDBG structures. 

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp kdbgscan
Volatile Systems Volatility Framework 1.4_rc1
Potential KDBG structure virtual addresses:
 _KDBG: 0x0296cbe8  (Win7SP0x86)
}}}

== kprcscan ==

Use this command to scan for potential KPCR structures. 

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp kpcrscan
Volatile Systems Volatility Framework 1.4_rc1
Potential KPCR structure virtual addresses:
 _KPCR: 8296dc00
}}}

= Processes and DLLs =

== pslist ==

To list the active processes of a system, use the pslist command. This walks the doubly-linked list pointed to by !PsActiveProcessHead. It does not detect hidden or unlinked processes. 

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp pslist
Volatile Systems Volatility Framework 1.4_rc1
Name                 Pid    PPid   Thds   Hnds   Time  
System                    4      0     90    516 2010-07-06 22:28:46       
smss.exe                252      4      2     29 2010-07-06 22:28:46       
csrss.exe               348    340     10    441 2010-07-06 22:28:53       
wininit.exe             384    340      3     73 2010-07-06 22:28:53       
csrss.exe               396    376      8    187 2010-07-06 22:28:53       
winlogon.exe            424    376      5    129 2010-07-06 22:28:54       
services.exe            492    384     12    216 2010-07-06 22:28:54       
lsass.exe               500    384      7    559 2010-07-06 22:28:54       
lsm.exe                 508    384     10    142 2010-07-06 22:28:54       
svchost.exe             616    492     10    348 2010-07-06 22:28:55
[snip]
}}}

The columns display the process ID, the parent process ID, number of threads, number of handles, and date/time when the process started. 

== pstree ==

To view the process listing in tree form, use the pstree command. This enumerates processes using the same technique as pslist, so it will also not show hidden or unlinked processes. Child process are indicated using indention and periods.

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp pstree
Volatile Systems Volatility Framework 1.4_rc1
Name                                        Pid    PPid   Thds   Hnds   Time  
 0x84E6E3D8:wininit.exe                        384    340      3     73 2010-07-06 22:28:53       
. 0x8D4CC030:services.exe                      492    384     12    216 2010-07-06 22:28:54       
.. 0x84E19030:svchost.exe                     1920    492      8    115 2010-07-06 22:33:17       
.. 0x8D4E5BB0:schtasks.exe                    2512    492      2     60 2010-07-06 22:39:09       
.. 0x8D7E9030:wsqmcons.exe                    2576    492      1      3 2010-07-06 22:39:11       
.. 0x8D5B18A8:dllhost.exe                     1944    492     16    187 2010-07-06 22:31:21       
.. 0x8D7EE030:taskhost.exe                    1156    492     10    155 2010-07-06 22:37:54       
.. 0x84D79D40:msdtc.exe                        284    492     15    152 2010-07-06 22:31:24       
.. 0x8D6781D8:svchost.exe                     1056    492     16    589 2010-07-06 22:29:31       
.. 0x8D777D40:taskhost.exe                    2520    492     11    224 2010-07-06 22:39:10       
.. 0x8D759470:sdclt.exe                       2504    492      1      4 2010-07-06 22:39:09       
.. 0x8D5574D8:rundll32.exe                    2484    492      1      5 2010-07-06 22:39:08       
.. 0x84D82C08:SearchIndexer.                  1464    492     18    624 2010-07-06 22:33:20       
... 0x8D759760:SearchFilterHo                 1724   1464      6     82 2010-07-06 22:37:36       
... 0x8D55E678:SearchProtocol                 2680   1464      8    231 2010-07-06 22:39:27       
.. 0x8D5CC030:svchost.exe                     1140    492     17    375 2010-07-06 22:29:51
[snip]
}}}

== psscan2 ==

To enumerate processes using pool tag scanning, use the psscan2 command. This can find processes that previously terminated (inactive) and processes that have been hidden or unlinked by a rootkit. 

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp psscan2
Volatile Systems Volatility Framework 1.4_rc1
PID    PPID   Time created             Time exited              Offset     PDB        Remarks
------ ------ ------------------------ ------------------------ ---------- ---------- ----------------
  2568    348 2010-07-06 22:39:11                               0x002cc030 0x09d54000 conhost.exe     
  1944    492 2010-07-06 22:31:21                               0x00ef48a8 0x08d61000 dllhost.exe     
  1312    492 2010-07-06 22:31:06                               0x00ffcd40 0x069a9000 spoolsv.exe     
  2484    492 2010-07-06 22:39:08                               0x01e584d8 0x07bdc000 rundll32.exe    
   348    340 2010-07-06 22:28:53                               0x03164d40 0x0cd84000 csrss.exe       
   492    384 2010-07-06 22:28:54                               0x040e2030 0x0dcb9000 services.exe    
  1880   1720 2010-07-06 22:38:07                               0x04a291a8 0x0db11000 explorer.exe    
  3064   1488 2010-07-06 22:40:27                               0x04b365b8 0x01961000 VMwareResoluti  
  2512    492 2010-07-06 22:39:09                               0x04dc3bb0 0x0fba2000 schtasks.exe    
  2576    492 2010-07-06 22:39:11                               0x053fe030 0x06e43000 wsqmcons.exe
[snip]
}}}

If a process has previously terminated, the Time exited field will show the exit time. If you want to investigate a hidden process (such as displaying its DLLs), then you'll need physical offset of the EPROCESS object, which is shown in the far left column.

== dlllist ==

To display a process's loaded DLLs, use the dlllist command. It walks the doubly-linked list of LDR_DATA_TABLE_ENTRY structures which is pointed to by the PEB's !InLoadOrderModuleList. DLLs are automatically added to this list when a process calls !LoadLibrary (or some derivative such as !LdrLoadDll) and they aren't removed until !FreeLibrary is called and the reference count reaches zero.

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp dlllist

[snip]

************************************************************************
services.exe pid:    492
Command line : C:\Windows\system32\services.exe

Base         Size         Path
0x00a50000   0x041000     C:\Windows\system32\services.exe
0x778a0000   0x13c000     C:\Windows\SYSTEM32\ntdll.dll
0x779f0000   0x0d4000     C:\Windows\system32\kernel32.dll
0x75ca0000   0x04a000     C:\Windows\system32\KERNELBASE.dll
0x75e40000   0x0ac000     C:\Windows\system32\msvcrt.dll
0x76650000   0x0a1000     C:\Windows\system32\RPCRT4.dll
0x758d0000   0x01a000     C:\Windows\system32\SspiCli.dll
0x759f0000   0x00b000     C:\Windows\system32\profapi.dll
0x75d80000   0x019000     C:\Windows\SYSTEM32\sechost.dll
0x75940000   0x00c000     C:\Windows\system32\CRYPTBASE.dll
0x758c0000   0x00f000     C:\Windows\system32\scext.dll
0x764a0000   0x0c9000     C:\Windows\system32\USER32.dll
0x765b0000   0x04e000     C:\Windows\system32\GDI32.dll
0x76330000   0x00a000     C:\Windows\system32\LPK.dll
[snip]
}}}

To display the DLLs for a specific process instead of all processes, use the -p or --pid filter like this:

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp dlllist --pid=492
}}}

To display the DLLs for a process that is hidden or unlinked by a rootkit, first use the psscan2 to get the physical offset of the EPROCESS object and then:

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp dlllist --offset=0x04a291a8
}}}

For more ways to list DLLs in a process, see the [http://code.google.com/p/volatility/wiki/CommandReference#ldrmodules ldrmodules] command.

== dlldump ==

To extract a DLL from a process's memory space and dump it to disk for analysis, use the dlldump command. The syntax is nearly the same as what we've shown for dlllist above. You can:

  * Dump all DLLs from all processes
  * Dump all DLLs from a specific process (with --pid=PID)
  * Dump all DLLs from a hidden/unlinked process (with --offset=OFFSET)

To specify an output directory, use --dump-dir=DIR or -d DIR. You can also supply a regular expression to dump a DLL with a particular pattern in its name. 

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp dlldump -r kernel32 -D out
Cannot dump TrustedInstall@kernel32.dll at 779f0000
Cannot dump WmiPrvSE.exe@kernel32.dll at 779f0000
Dumping kernel32.dll, Process: SearchFilterHo, Base: 779f0000 output: module.6bc.da1d760.779f0000.dll
Dumping kernel32.dll, Process: taskhost.exe, Base: 779f0000 output: module.484.546d030.779f0000.dll
Cannot dump dwm.exe@kernel32.dll at 779f0000
Dumping kernel32.dll, Process: explorer.exe, Base: 779f0000 output: module.758.4a291a8.779f0000.dll
Cannot dump wuauclt.exe@kernel32.dll at 779f0000
Dumping kernel32.dll, Process: VMwareTray.exe, Base: 779f0000 output: module.860.fe828d8.779f0000.dll
[snip]
}}}

If the extraction fails, as it did for a few processes above, it probably means that some of the memory pages in that process were not memory resident at the time (due to paging). 

To dump a PE file that doesn't exist in the DLLs list (for example, due to code injection or malicious unlinking), just specify the base address of the PE in process memory:

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp dlldump --pid=492 -D out --base=0x00680000
}}}

== files ==

To display the open file handles in a process, use the files command. A process can obtain a file handle by calling functions such as !CreateFile, and the handle will stay valid until !CloseHandle is called.

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp files -p 4
Volatile Systems Volatility Framework 1.4_rc1
Pid:      4
File   '\\Windows\\System32\\wdi\\LogFiles\\WdiContextLog.etl.001'
File   '\\Windows\\System32\\config\\RegBack\\SECURITY'
File   '\\Windows\\System32\\config\\SECURITY' 
File   '\\Windows\\System32\\config\\RegBack\\DEFAULT'
File   '\\Windows\\System32\\config\\RegBack\\SAM'
File   '\\pagefile.sys'                        
File   '\\Windows\\System32\\config\\SYSTEM'   
File   '\\Windows\\System32\\LogFiles\\WMI\\RtBackup\\EtwRTUBPM.etl'
File   '\\Windows\\System32\\config\\DEFAULT.LOG1'
File   '\\Windows\\System32\\config\\DEFAULT.LOG2'
File   '\\Windows\\System32\\config\\DEFAULT'  
[snip]
}}}

== regobjkeys ==

To display the open registry handles in a process, use the regobjkeys command. A process can obtain a handle to a registry key by calling a function such as !RegOpenKeyEx or !RegCreateKey, and it stays valid until !RegCloseKey is called. 

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp regobjkeys -p 4
Volatile Systems Volatility Framework 1.4_rc1
Pid:      4
Key    MACHINE\SYSTEM\CONTROLSET001\CONTROL\HIVELIST                        
Key    MACHINE\SYSTEM\CONTROLSET001\CONTROL\PRODUCTOPTIONS
Key    MACHINE\SYSTEM\CONTROLSET001\CONTROL\SESSION MANAGER\MEMORY MANAGEMENT\PREFETCHPARAMETERS
Key    MACHINE\SYSTEM\SETUP                    
Key    MACHINE\HARDWARE\DESCRIPTION\SYSTEM\MULTIFUNCTIONADAPTER
Key    MACHINE\SYSTEM\CONTROLSET001            
Key    MACHINE\SYSTEM\CONTROLSET001\ENUM       
Key    MACHINE\SYSTEM\CONTROLSET001\CONTROL\CLASS
Key    MACHINE\SYSTEM\CONTROLSET001\SERVICES   
Key    MACHINE\SYSTEM\CONTROLSET001\CONTROL\WMI\SECURITY
Key    MACHINE\SYSTEM\CONTROLSET001\CONTROL\LSA
[snip]
}}}

== getsids ==

To view the SIDs (Security Identifiers) associated with a process, use the getsids command. Among other things, this can help you identify processes which have maliciously escalated privileges. 

For more information, see BDG's [http://moyix.blogspot.com/2008/08/linking-processes-to-users.html Linking Processes To Users].

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp getsids 
Volatile Systems Volatility Framework 1.4_rc1
System (4): S-1-5-18 (Local System)
System (4): S-1-5-32-544 (Administrators)
System (4): S-1-1-0 (Everyone)
System (4): S-1-5-11 (Authenticated Users)
System (4): S-1-16-16384 (System Mandatory Level)
smss.exe (252): S-1-5-18 (Local System)
smss.exe (252): S-1-5-32-544 (Administrators)
smss.exe (252): S-1-1-0 (Everyone)
smss.exe (252): S-1-5-11 (Authenticated Users)
smss.exe (252): S-1-16-16384 (System Mandatory Level)
[snip]
}}}

== verinfo ==

To display the version information embedded in PE files, use the verinfo command. Not all PE files have version information, and many malware authors forge it to include false data, but nonetheless this command can be very helpful with identifying binaries and for making correlations with other files. 

This command supports filtering by process ID, regular expression, and EPROCESS offset. 

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp verinfo
[snip]

C:\Windows\system32\CRYPTBASE.dll
C:\Windows\system32\winlogon.exe
  File version    : 6.1.7600.16447
  Product version : 6.1.7600.16447
  Flags           : 
  OS              : Windows NT
  File Type       : Application
  File Date       : 
  CompanyName : Microsoft Corporation
  FileDescription : Windows Logon Application
  FileVersion : 6.1.7600.16447 (win7_gdr.091027-1503)
  InternalName : winlogon
  LegalCopyright : \xa9 Microsoft Corporation. All rights reserved.
  OriginalFilename : WINLOGON.EXE
  ProductName : Microsoft\xae Windows\xae Operating System
  ProductVersion : 6.1.7600.16447

[snip] 

C:\Windows\System32\ntlanman.dll
  File version    : 6.1.7600.16385
  Product version : 6.1.7600.16385
  Flags           : 
  OS              : Windows NT
  File Type       : Dynamic Link Library
  File Date       : 
  CompanyName : Microsoft Corporation
  FileDescription : Microsoft\xae Lan Manager
  FileVersion : 6.1.7600.16385 (win7_rtm.090713-1255)
  InternalName : ntlanman.dll
  LegalCopyright : \xa9 Microsoft Corporation. All rights reserved.
  OriginalFilename : ntlanman.dll
  ProductName : Microsoft\xae Windows\xae Operating System
  ProductVersion : 6.1.7600.16385

[snip]
}}}

You can also reference the verinfo plugin for an example of how to parse PE headers in memory images, if you happen to be looking for other information such as digital signatures, resources, import and export tables, etc. 

= Process Memory =

== memmap ==

For a brief inspection of the addressable memory pages in a process, use the memmap command. 

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp -p 1880 memmap 
explorer.exe pid:   1880
Virtual      Physical     Size        
0x0000010000 0x00075cb000 0x000000001000
0x0000021000 0x0009c2c000 0x000000001000
0x0000030000 0x0002adf000 0x000000001000
0x0000031000 0x0000d99000 0x000000001000
0x0000032000 0x000583a000 0x000000001000
0x0000040000 0x000a25b000 0x000000001000
0x0000041000 0x00044d6000 0x000000001000
0x0000050000 0x00099ee000 0x000000001000
0x0000060000 0x000b155000 0x000000001000
[snip]
}}}

== memdump ==

To extract all data from the various memory segments in a process and dump them to a single file, use the memdump command. 

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp -p 1880 memdump -D memory/
Volatile Systems Volatility Framework 1.4_rc1
************************************************************************
Writing explorer.exe [  1880] to 1880.dmp

$ ls -alh memory/1880.dmp 
-rw-r--r--  1 User  staff   140M Feb  8 15:13 memory/1880.dmp
}}}

== procmemdump ==

To dump a process's executable (including the slack space), use the procmemdump command. Optionally, pass the --unsafe or -u flags to bypass certain sanity checks used when parsing the PE header. For example, some malware will intentionally forge size fields in the PE header so that memory dumping tools fail. 

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp -p 1880 procmemdump -D memory/
Volatile Systems Volatility Framework 1.4_rc1
************************************************************************
Dumping explorer.exe, pid:   1880 output: executable.1880.exe

$ file memory/executable.1880.exe 
memory/executable.1880.exe: PE32 executable for MS Windows (GUI) Intel 80386 32-bit
}}}

== procexedump ==

To dump a process's executable (*not* including the slack space), use the procexedump command. The syntax is identical to procmemdump.

== vadwalk ==

To briefly inspect a process's VAD nodes, use the vadwalk command. For more information on the VAD, see BDG's [http://www.dfrws.org/2007/proceedings/p62-dolan-gavitt.pdf The VAD Tree: A Process-Eye View of Physical Memory].

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp -p 1880 vadwalk
Volatile Systems Volatility Framework 1.4_rc1
************************************************************************
Pid:   1880
Address  Parent   Left     Right    Start    End      Tag  Flags
8d5487b8 00000000 8d6a4a20 8d7d5ef8 6ce80000 6ceeefff Vad 
8d6a4a20 00000000 8d57ed70 84e4e7f8 02e30000 02e31fff VadS
8d57ed70 8d6a4a20 8d6cffb8 8d7c5c20 01c90000 01e8ffff Vadm
8d6cffb8 00000000 8d760e58 8d457268 00a20000 00ca0fff Vadm
8d760e58 00000000 84d529c0 84d2a1b8 00090000 000cffff VadS
84d529c0 00000000 84e689a0 8d782428 00040000 00041fff Vad 
84e689a0 84d529c0 84d52708 83efff78 00020000 00021fff Vad 
84d52708 84e689a0 00000000 00000000 00010000 0001ffff Vad 
83efff78 84e689a0 00000000 00000000 00030000 00033fff Vad 
[snip]
}}}

== vadtree ==

To display the VAD nodes in a visual tree form, use the vadtree command. 

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp -p 1880 vadtree
Volatile Systems Volatility Framework 1.4_rc1
************************************************************************
Pid:   1880
6ce80000 - 6ceeefff
02e30000 - 02e31fff
 01c90000 - 01e8ffff
00a20000 - 00ca0fff
00090000 - 000cffff
00040000 - 00041fff
 00020000 - 00021fff
  00010000 - 0001ffff
}}}

If you want to view the balanced binary tree in Graphviz format, use the dot output rendering:

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp -p 1880 vadtree --output=dot --output-file=graph.dot
}}}

Now you can open graph.dot in any Graphviz-compatible viewer. 

== vadinfo ==

The vadinfo command displays extended information about a process's VAD nodes. In particular, it shows:

  * The address of the MMVAD structure in kernel memory
  * The starting and ending virtual addresses in process memory
  * The VAD Tag 
  * The memory protection constant (permissions)
  * The name of the memory mapped file (if one exists)

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp -p 1880 vadinfo

VAD node @8d570798 Start 05330000 End 0536ffff Tag VadS
Flags: PrivateMemory
Commit Charge: 18 Protection: 4

VAD node @8d6d78a0 Start 05850000 End 0588ffff Tag VadS
Flags: PrivateMemory
Commit Charge: 16 Protection: 4

VAD node @84f40530 Start 6c750000 End 6c756fff Tag Vad 
Flags: UserPhysicalPages
Commit Charge: 2 Protection: 7
ControlArea @84d501e8 Segment 99e28118
Dereference list: Flink 00000000, Blink 00000000
NumberOfSectionReferences:          0 NumberOfPfnReferences:           1
NumberOfMappedViews:                1 NumberOfUserReferences:          1
WaitingForDeletion Event:  00000000
Flags: File, Image
FileObject @84e8e910 FileBuffer @ 9c52c7b0          , Name: \Windows\System32\msiltcfg.dll
First prototype PTE: 99e28144 Last contiguous PTE: fffffffc
Flags2: Inherit
File offset: 00000000

[snip]
}}}

== vaddump ==

To extract the data contained within each VAD segment, use the vaddump command. This is similar to [http://code.google.com/p/volatility/wiki/CommandReference#memdump memdump], except the data ends up in separate files, named according to the address in process memory where the data was found. 

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp vaddump -D vads
Volatile Systems Volatility Framework 1.4_rc1
Pid:      4
************************************************************************
Pid:    252
************************************************************************
Pid:    348
************************************************************************
Pid:    384
************************************************************************
Pid:    396
************************************************************************
Pid:    424
[snip]

$ ls -alh vads/
-rw-r--r--    1 User  staff   128K Feb  8 15:29 System.a2d960.00120000-0013ffff.dmp
-rw-r--r--    1 User  staff   128K Feb  8 15:29 System.a2d960.00140000-0015ffff.dmp
-rw-r--r--    1 User  staff   128K Feb  8 15:29 System.a2d960.00160000-0017ffff.dmp
-rw-r--r--    1 User  staff   128K Feb  8 15:29 System.a2d960.00180000-0019ffff.dmp
-rw-r--r--    1 User  staff   1.2M Feb  8 15:29 System.a2d960.778a0000-779dbfff.dmp
-rw-r--r--    1 User  staff   1.0M Feb  8 15:29 csrss.exe.3164d40.00000000-000fffff.dmp
-rw-r--r--    1 User  staff   412K Feb  8 15:29 csrss.exe.3164d40.00100000-00166fff.dmp
-rw-r--r--    1 User  staff   4.0K Feb  8 15:29 csrss.exe.3164d40.00170000-00170fff.dmp
-rw-r--r--    1 User  staff   8.0K Feb  8 15:29 csrss.exe.3164d40.00180000-00181fff.dmp
-rw-r--r--    1 User  staff   4.0K Feb  8 15:29 csrss.exe.3164d40.00190000-00190fff.dmp
[snip]
}}}

The files are named like this:

!ProcessName.!PhysicalOffset.StartingVPN.EndingVPN.dmp

The reason the !PhysicalOffset field exists is so you can distinguish between two processes with the same name. 

= Kernel Memory and Objects =

== modules ==

To view the list of kernel drivers loaded on the system, use the modules command. This walks the doubly-linked list of LDR_DATA_TABLE_ENTRY structures pointed to by !PsLoadedModuleList. It cannot find hidden/unlinked kernel drivers.

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp modules
Volatile Systems Volatility Framework 1.4_rc1
File                                               Base         Size     Name
\SystemRoot\system32\ntoskrnl.exe                  0x008284c000 0x400000 ntoskrnl.exe
\SystemRoot\system32\halmacpi.dll                  0x0082815000 0x037000 hal.dll
\SystemRoot\system32\kdcom.dll                     0x0080bcc000 0x008000 kdcom.dll
\SystemRoot\system32\mcupdate_GenuineIntel.dll     0x0085c2d000 0x078000 mcupdate.dll
\SystemRoot\system32\PSHED.dll                     0x0085ca5000 0x011000 PSHED.dll
\SystemRoot\system32\BOOTVID.dll                   0x0085cb6000 0x008000 BOOTVID.dll
\SystemRoot\system32\CLFS.SYS                      0x0085cbe000 0x042000 CLFS.SYS
\SystemRoot\system32\CI.dll                        0x0085d00000 0x0ab000 CI.dll
\SystemRoot\system32\drivers\Wdf01000.sys          0x0085dab000 0x071000 Wdf01000.sys
\SystemRoot\system32\drivers\WDFLDR.SYS            0x0085e1c000 0x00e000 WDFLDR.SYS
\SystemRoot\system32\DRIVERS\ACPI.sys              0x0085e2a000 0x048000 ACPI.sys
\SystemRoot\system32\DRIVERS\WMILIB.SYS            0x0085e72000 0x009000 WMILIB.SYS
[snip] 
}}}

== modscan2 ==

To scan physical memory for kernel modules, use the modscan2 command. This can pick up previously unloaded drivers and drivers that have been hidden/unlinked by rootkits. 

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp modscan2
Volatile Systems Volatility Framework 1.4_rc1
File                                               Base         Size     Name
'\\SystemRoot\\System32\\Drivers\\spldr.sys'       0x00865c9000 0x008000 'spldr.sys'
'\\SystemRoot\\system32\\DRIVERS\\volsnap.sys'     0x008658a000 0x03f000 'volsnap.sys'
'\\SystemRoot\\system32\\DRIVERS\\vmstorfl.sys'    0x0086581000 0x009000 'vmstorfl.sys'
'\\SystemRoot\\System32\\drivers\\fwpkclnt.sys'    0x0086550000 0x031000 'fwpkclnt.sys'
'\\SystemRoot\\System32\\drivers\\tcpip.sys'       0x0086407000 0x149000 'tcpip.sys'
'\\SystemRoot\\System32\\Drivers\\ksecpkg.sys'     0x0086333000 0x025000 'ksecpkg.sys'
'\\SystemRoot\\system32\\drivers\\NETIO.SYS'       0x00862f5000 0x03e000 'NETIO.SYS'
'\\SystemRoot\\system32\\drivers\\ndis.sys'        0x008623e000 0x0b7000 'ndis.sys'
'\\SystemRoot\\System32\\Drivers\\Fs_Rec.sys'      0x0086235000 0x009000 'Fs_Rec.sys'
'\\SystemRoot\\System32\\drivers\\pcw.sys'         0x0086227000 0x00e000 'pcw.sys'
'\\SystemRoot\\System32\\Drivers\\cng.sys'         0x00861ca000 0x05d000 'cng.sys'
'\\SystemRoot\\System32\\Drivers\\ksecdd.sys'      0x00861b7000 0x013000 'ksecdd.sys'
[snip]
}}}

== moddump ==

To extract a kernel driver to a file, use the moddump command. It supports filtering by regular expression (case sensitive or not) and by physical offsets. To dump all drivers, don't use any command-line filters. 

For more information, see BDG's [http://moyix.blogspot.com/2008/10/plugin-post-moddump.html Plugin Post: Moddump].

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp moddump -D mods/
Volatile Systems Volatility Framework 1.4_rc1
Dumping ntoskrnl.exe, Base: 8284c000 output: driver.8284c000.sys
Dumping hal.dll, Base: 82815000 output: driver.82815000.sys
Dumping fwpkclnt.sys, Base: 86550000 output: driver.86550000.sys
Dumping kdcom.dll, Base: 80bcc000 output: driver.80bcc000.sys
Dumping NDProxy.SYS, Base: 8c7ec000 output: driver.8c7ec000.sys
Dumping CLFS.SYS, Base: 85cbe000 output: driver.85cbe000.sys
Dumping luafv.sys, Base: 8840c000 output: driver.8840c000.sys
Dumping peauth.sys, Base: 8857c000 output: driver.8857c000.sys
[snip]
}}}

== ssdt ==

To list the functions in the Native and GUI SSDTs, use the ssdt command. This displays the index, function name, and owning driver for each entry in the SSDT. Please note the following very important facts:

  * Windows has 4 SSDTs by default (you can add more with !KeAddSystemServiceTable), but only 2 of them are used - one for Native functions in the NT module, and one for GUI functions in the win32k.sys module. 
  * There are multiple ways to locate the SSDTs in memory. Most tools do it by finding the exported !KeServiceDescriptorTable symbol in the NT module, but this is not the way Volatility works. Volatility scans for ETHREAD objects (see the [http://code.google.com/p/volatility/wiki/CommandReference#thrdscan2 thrdscan2] command) and gathers all unique ETHREAD.Tcb.!ServiceTable pointers. This method is more robust and complete, because it can detect when rootkits make copies of the existing SSDTs and assign them to particular threads. Also see the [http://code.google.com/p/volatility/wiki/CommandReference#ssdt_by_threads ssdt_by_threads] command. 
  * The order and total number of functions in the SSDT differs across operating system versions. Thus, Volatility stores the information in a per-profile (OS) manner. 
  * For more information, see BDG's [http://moyix.blogspot.com/2008/08/auditing-system-call-table.html Auditing the System Call Table].

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp ssdt 
Volatile Systems Volatility Framework 1.4_rc1
Gathering all referenced SSDTs from KTHREADs...
Finding appropriate address space for tables...
SSDT[0] at 828a8634 with 401 entries
  Entry 0x0000: 0x82a8530e (NtAcceptConnectPort) owned by ntoskrnl.exe
  Entry 0x0001: 0x828d6774 (NtAccessCheck) owned by ntoskrnl.exe
  Entry 0x0002: 0x82abd460 (NtAccessCheckAndAuditAlarm) owned by ntoskrnl.exe
  Entry 0x0003: 0x82901dea (NtAccessCheckByType) owned by ntoskrnl.exe
  Entry 0x0004: 0x82a9f99a (NtAccessCheckByTypeAndAuditAlarm) owned by ntoskrnl.exe
  Entry 0x0005: 0x8294145a (NtAccessCheckByTypeResultList) owned by ntoskrnl.exe

[snip]

SSDT[1] at 977a5000 with 825 entries
  Entry 0x1000: 0x9772eb34 (NtGdiAbortDoc) owned by win32k.sys
  Entry 0x1001: 0x9774752e (NtGdiAbortPath) owned by win32k.sys
  Entry 0x1002: 0x975adc1a (NtGdiAddFontResourceW) owned by win32k.sys
  Entry 0x1003: 0x9773e5ae (NtGdiAddRemoteFontToDC) owned by win32k.sys
  Entry 0x1004: 0x97748c89 (NtGdiAddFontMemResourceEx) owned by win32k.sys
  Entry 0x1005: 0x9772f351 (NtGdiRemoveMergeFont) owned by win32k.sys
  Entry 0x1006: 0x9772f3e5 (NtGdiAddRemoteMMInstanceToDC) owned by win32k.sys
  Entry 0x1007: 0x976545cc (NtGdiAlphaBlend) owned by win32k.sys

[snip]
}}}

To filter all functions which point to ntoskrnl.exe and win32k.sys, you can use egrep on command-line. This will only show hooked SSDT functions. 

== driverscan ==

To scan for DRIVER_OBJECTs in physical memory, use the driverscan command. This is another way to locate kernel modules, although not all kernel modules have an associated DRIVER_OBJECT. The DRIVER_OBJECT is what contains the 28 IRP (Major Function) tables, thus the [http://code.google.com/p/volatility/wiki/CommandReference#driverirp driverirp] command is based on the methodology used by driverscan. 

For more information, see Andreas Schuster's [http://computer.forensikblog.de/en/2009/04/scanning_for_drivers.html Scanning for Drivers].

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp driverscan 
Volatile Systems Volatility Framework 1.4_rc1
Phys.Addr. Obj Type   #Ptr #Hnd Start        Size Service key          Name
0x007f1300 0x0000001a   67    0 0x85e2a000 294912 'ACPI'               'ACPI'       '\\Driver\\ACPI'
0x007f1b30 0x0000001a    3    0 0x85dab000 462848 'Wdf01000'           'Wdf01000'   '\\Driver\\Wdf01000'
0x00c630d8 0x0000001a    3    0 0x88427000  65536 'lltdio'             'lltdio'     '\\Driver\\lltdio'
0x00cb0108 0x0000001a    3    0 0x88437000  77824 'rspndr'             'rspndr'     '\\Driver\\rspndr'
0x00dedd38 0x0000001a    4    0 0x8844a000 544768 'HTTP'               'HTTP'       '\\Driver\\HTTP'
0x05533b88 0x0000001a    3    0 0x88573000  28672 'Parvdm'             'Parvdm'     '\\Driver\\Parvdm'
0x0ad99af8 0x0000001a    5    0 0x8c400000  94208 'usbccgp'            'usbccgp'    '\\Driver\\usbccgp'
0x0bd46650 0x0000001a    3    0 0x8857a000   7680 'VMMEMCTL'           'VMMEMCTL'   '\\Driver\\VMMEMCTL'
0x0c8b5400 0x0000001a    2    0 0x8840c000 110592 'luafv'              'luafv'      '\\FileSystem\\luafv'
0x0d747c18 0x0000001a    3    0 0x884cf000 102400 'bowser'             'bowser'     '\\FileSystem\\bowser'
0x0d98cc60 0x0000001a    3    0 0x8864b000 323584 'srv2'               'srv2'       '\\FileSystem\\srv2'
[snip]
}}}

== filescan ==

To scan physical memory for FILE_OBJECTs, use the filescan command. This will find open files even if a rootkit is hiding the files on disk and if the rootkit hooks some API functions to hide the open handles on a live system. The output shows the physical offset of the FILE_OBJECT, file name, number of pointers to the object, number of handles to the object, and the effective permissions granted to the object. 

For more information, see Andreas Schuster's [http://computer.forensikblog.de/en/2009/04/scanning_for_file_objects.html Scanning for File Objects] and [http://computer.forensikblog.de/en/2009/04/linking_file_objects_to_processes.html Linking File Objects To Processes]. 

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp filescan
Volatile Systems Volatility Framework 1.4_rc1
Phys.Addr. Obj Type   #Ptr #Hnd Access Name
0x007b1020 0x0000001c   17    0 RW-rwd '\\$Directory'
0x007b1280 0x0000001c    8    1 R--r-d '\\Windows\\System32\\en-US\\gpsvc.dll.mui'
0x00921bb8 0x0000001c    2    0 R--r-d '\\Windows\\System32\\msftedit.dll'
0x00be5950 0x0000001c    1    1 R--rw- '\\Windows\\System32'
0x00be76b8 0x0000001c    7    0 R--r-- '\\Windows\\Fonts\\marlett.ttf'
0x00bf2370 0x0000001c    8    0 R--r-d '\\Windows\\System32\\sscore.dll'
0x00bf2520 0x0000001c    9    1 R--r-d '\\Windows\\System32\\en-US\\sysmain.dll.mui'
0x00c23a68 0x0000001c    3    0 R--r-d '\\Windows\\System32\\wkssvc.dll'
0x00c23db0 0x0000001c    1    1 ------ '\\srvsvc'
0x00c5a910 0x0000001c   17    0 RW-rwd '\\$Directory'
0x00c5ab10 0x0000001c    5    0 R--r-d '\\Windows\\System32\\w32time.dll'
0x00c64228 0x0000001c   16    1 RW-r-- '\\Windows\\System32\\winevt\\Logs\\Microsoft-Windows-GroupPolicy%4Operational.evtx'
0x00c64610 0x0000001c    8    0 R--r-d '\\Windows\\System32\\RpcRtRemote.dll'
0x00c648a0 0x0000001c    6    0 R--r-d '\\Windows\\System32\\ntlanman.dll'
0x00c70c70 0x0000001c    1    1 ------ '\\wkssvc'
0x00ca3530 0x0000001c    4    0 ------ '\\Windows\\System32\\locale.nls'
0x00ca3ea8 0x0000001c    3    0 R--r-d '\\Windows\\System32\\wiarpc.dll'
0x00ca4330 0x0000001c    3    0 R--r-d '\\Windows\\System32\\Sens.dll'
0x00ca4b48 0x0000001c    2    0 R--r-d '\\Windows\\System32\\ktmw32.dll'
0x00ca4c00 0x0000001c    6    0 R--r-d '\\Windows\\System32\\schedsvc.dll'
0x00cad020 0x0000001c    1    1 R--r-- '\\Windows\\Registration\\R000000000006.clb'
0x00cadc28 0x0000001c    1    1 ------ '\\wkssvc'
0x00cade78 0x0000001c    1    1 ------ '\\wkssvc'
[snip]
}}}

== mutantscan ==

To scan physical memory for KMUTANT objects, use the mutantscan command. By default, it displays all objects, but you can pass -s or --silent to only show named mutexes. The CID column contains the process ID and thread ID of the mutex owner if one exists.

For more information, see Andreas Schuster's [http://computer.forensikblog.de/en/2009/04/searching_for_mutants.html Searching for Mutants].

Since mutexes can have seemingly random names, and there are so many of them, its difficult to spot malicious mutexes. For this reason, we built a proof-of-concept mutanscandb command which gathers mutex names from online sandboxes and populates an sqlite3 database with them. Then the Volatility command reads in the mutexes and highlights entries in your memory dump which also exist in the sqlite3 database. 

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp mutantscan -s
Volatile Systems Volatility Framework 1.4_rc1
Phys.Addr. Obj Type   #Ptr #Hnd Signal Thread     CID        Name
0x07f955a0 0x0000000e    2    1      1 0x00000000            'TapiSrv_Perf_Library_Lock_PID_5d0'
0x081b5ce8 0x0000000e    2    1      1 0x00000000            'WininetProxyRegistryMutex'
0x08ffccc8 0x0000000e    3    2      1 0x00000000            'ZoneAttributeCacheCounterMutex'
0x099f21f8 0x0000000e    2    1      1 0x00000000            '_!MSFTHISTORY!_'
0x099f2e58 0x0000000e    2    1      1 0x00000000            'ZonesCacheCounterMutex'
0x09aa83a0 0x0000000e    2    1      1 0x00000000            'ZonesLockedCacheCounterMutex'
0x09aa8bd0 0x0000000e    2    1      1 0x00000000            'ZonesCacheCounterMutex'
0x09d06c18 0x0000000e    2    1      1 0x00000000            'VMwareGuestDnDDataMutex'
0x0afe45d8 0x0000000e    2    1      1 0x00000000            '__?_c:_programdata_microsoft_rac_temp_sql4c79.tmp:x'
0x0b6ea040 0x0000000e    2    1      0 0x83ecd030 2520:2616  'F659A567-8ACB-4E4A-92A7-5C2DD1884F72'
0x0be081e8 0x0000000e    2    1      1 0x00000000            'BITS_Perf_Library_Lock_PID_5d0'
[snip]
}}}

== thrdscan2 ==

To scan for ETHREAD objects in physical memory, use the thrdscan2 command. Since an ETHREAD contains fields that identify its parent process, you can use this technique to find hidden processes. One such use case is documented in the [http://code.google.com/p/volatility/wiki/CommandReference#orphanthreads orphanthreads] command. 

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp thrdscan2
Volatile Systems Volatility Framework 1.4_rc1
PID    TID    Create Time               Exit Time                 Offset    
------ ------ ------------------------- ------------------------- ----------
   876   2424                                                     0x006960c8
   348    480                                                     0x007b1538
  1344   1964                                                     0x00c62030
  1140   1404                                                     0x00c62d48
  1312   1224                                                     0x00c64ad8
   876   1236                                                     0x00ca4cc8
   840   1800                           2010-07-06 22:33:47       0x00cea150
  1344   1352                                                     0x00d62bb8
  1140   1440                                                     0x00eb4d48
  1920    800                                                     0x00ebf030
   384    388                                                     0x00ebf538
   876   1320                           2010-07-06 22:38:33       0x00ebf978
  1880   2372                                                     0x00eef548
   876   1164                                                     0x00ef8030
[snip]
}}}

= Networking =

== connections ==

To view the active connections, use the connections command. This walks the singly-linked list of connection structures pointed to by a non-exported symbol in the tcpip.sys module. This command is for Windows XP only. 

{{{
$ python volatility.py --profile=WinXPSP3x86 -f silentbanker.vmem connections
Volatile Systems Volatility Framework 1.4_rc1
Local Address             Remote Address            Pid   
192.168.128.128:1299      207.46.216.54:80            1876
192.168.128.128:1293      8.12.206.126:80             1876
192.168.128.128:1276      207.68.173.76:80            1876
192.168.128.128:1285      208.59.255.160:80           1876
192.168.128.128:1274      65.55.12.249:80             1876
192.168.128.128:1275      65.54.77.76:80              1876
192.168.128.128:1294      65.55.15.241:80             1876
192.168.128.128:1288      65.55.149.122:80            1876
192.168.128.128:1281      199.93.33.126:80            1876
[snip]
}}}

== connscan2 ==

To find connection structures using pool tag scanning, use the connscan2 command. This can find artifacts from previous connections that have since been terminated. In the output below, you'll notice some fields have been partially overwritten, but some of the information is still accurate. Thus, while it may find false positives sometimes, you also get the benefit of detecting as much information as possible. This command is for Windows XP only. 

{{{
$ python volatility.py --profile=WinXPSP3x86 -f silentbanker.vmem connscan2
Volatile Systems Volatility Framework 1.4_rc1
Local Address             Remote Address            Pid   
------------------------- ------------------------- ------ 
192.168.128.128:1295      65.55.15.125:80             1876
192.168.128.128:1297      209.62.188.19:80            1876
192.168.128.128:1298      209.62.176.153:80           1876
192.168.128.128:1282      199.93.33.126:80            1876
192.168.128.128:1281      199.93.33.126:80            1876
192.168.128.128:1283      66.235.138.18:80            1876
192.168.128.128:1284      65.55.239.189:80            1876
192.168.128.128:1274      65.55.12.249:80             1876
192.168.128.128:1275      65.54.77.76:80              1876
192.168.128.128:1277      199.93.33.126:80            1876
192.168.128.128:1280      8.12.206.126:80             1876
115.37.0.0:28526          78.101.120.116:67         1952671086
116.101.73.112:25714      82.101.109.111:16740      1953723237
9.0.0.0:25441             80.105.100.116:19567      1919897708
[snip]
}}}

== sockets ==

To detect listening sockets for any protocol (TCP, UDP, RAW, etc), use the sockets command. This walks a singly-linked list of socket structures which is pointed to by a non-exported symbol in the tcpip.sys module. This command is for Windows XP only. 

{{{
$ python volatility.py --profile=WinXPSP3x86 -f silentbanker.vmem sockets
Volatile Systems Volatility Framework 1.4_rc1
Pid    Port   Proto  Create Time               
  1876   1274      6 2009-02-18 06:55:23       
  1876   1282      6 2009-02-18 06:55:24       
  1156   1900     17 2008-12-11 20:51:52       
  1876   1273     17 2009-02-18 06:55:20       
   740    500     17 2008-09-18 05:33:19       
     4    139      6 2008-12-11 20:51:51       
  1876   1290      6 2009-02-18 06:55:26       
  1876   1294      6 2009-02-18 06:55:29
[snip]
}}}

== sockscan ==

To find socket structures using pool tag scanning, use the sockscan command. As with connscan2, this can pick up residual data and artifacts from previous sockets, and it only applies to Windows XP. 

{{{
$ python volatility.py --profile=WinXPSP3x86 -f silentbanker.vmem sockscan
Volatile Systems Volatility Framework 1.4_rc1
PID    Port   Proto  Create Time                Offset 
------ ------ ------ -------------------------- ----------
  1876   1297      6 2009-02-18 06:55:30        0x0161c1d8
  1876   1294      6 2009-02-18 06:55:29        0x0161fbc0
  1876   1295      6 2009-02-18 06:55:29        0x01622e98
  1876   1299      6 2009-02-18 06:55:30        0x0162ac38
  1876   1293      6 2009-02-18 06:55:28        0x0162b5b8
  1876   1273     17 2009-02-18 06:55:20        0x016523a8
  1876   1279      6 2009-02-18 06:55:24        0x01668c68
     4    137     17 2008-12-11 20:51:51        0x01677388
  1876   1277      6 2009-02-18 06:55:24        0x01680e98
[snip]
}}}

== netscan ==

To scan for network artifacts in Windows Vista and Windows 7 memory dumps, use the netscan command. This finds TCP endpoints, TCP listeners, UDP endpoints, and UDP listeners. It distinguishes between IPv4 and IPv6, prints the local and remote IP (if applicable), the local and remote port (if applicable), the time when the socket was bound or when the connection was established, and the current state (for TCP connections only). 

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp netscan 
Volatile Systems Volatility Framework 1.4_rc1
Offset     Proto    Local Address                  Foreign Address      State            Pid      Owner          Created
0xca3008   TCPv4    192.168.181.133:139            0.0.0.0:0            LISTENING        4        System         1970-01-01 00:00:00 
0x3027008  TCPv4    0.0.0.0:49155                  0.0.0.0:0            LISTENING        876      svchost.exe    1970-01-01 00:00:00 
0x3027008  TCPv6    :::49155                       :::0                 LISTENING        876      svchost.exe    1970-01-01 00:00:00 
0x5ac5c80  TCPv4    0.0.0.0:49153                  0.0.0.0:0            LISTENING        728      svchost.exe    1970-01-01 00:00:00 
0x5ac5c80  TCPv6    :::49153                       :::0                 LISTENING        728      svchost.exe    1970-01-01 00:00:00 
0xbfe1208  TCPv4    0.0.0.0:49152                  0.0.0.0:0            LISTENING        384      wininit.exe    1970-01-01 00:00:00 
0xbfe1208  TCPv6    :::49152                       :::0                 LISTENING        384      wininit.exe    1970-01-01 00:00:00 
0xbfe1648  TCPv4    0.0.0.0:49152                  0.0.0.0:0            LISTENING        384      wininit.exe    1970-01-01 00:00:00 
0xc1fad48  TCPv4    0.0.0.0:49153                  0.0.0.0:0            LISTENING        728      svchost.exe    1970-01-01 00:00:00 
0xc5ae148  TCPv4    0.0.0.0:135                    0.0.0.0:0            LISTENING        680      svchost.exe    1970-01-01 00:00:00 
0xc6f5bb0  TCPv4    0.0.0.0:135                    0.0.0.0:0            LISTENING        680      svchost.exe    1970-01-01 00:00:00 
0xc6f5bb0  TCPv6    :::135                         :::0                 LISTENING        680      svchost.exe    1970-01-01 00:00:00 
0xd816270  TCPv4    0.0.0.0:445                    0.0.0.0:0            LISTENING        4        System         1970-01-01 00:00:00 
0xd816270  TCPv6    :::445                         :::0                 LISTENING        4        System         1970-01-01 00:00:00 
0xdc5a368  TCPv4    0.0.0.0:49156                  0.0.0.0:0            LISTENING        492      services.exe   1970-01-01 00:00:00 
0xde59008  TCPv4    0.0.0.0:49156                  0.0.0.0:0            LISTENING        492      services.exe   1970-01-01 00:00:00 
0xde59008  TCPv6    :::49156                       :::0                 LISTENING        492      services.exe   1970-01-01 00:00:00 
0xed29808  TCPv4    0.0.0.0:49155                  0.0.0.0:0            LISTENING        876      svchost.exe    1970-01-01 00:00:00 
0xee49450  TCPv4    0.0.0.0:49154                  0.0.0.0:0            LISTENING        500      lsass.exe      1970-01-01 00:00:00 
0xee52d98  TCPv4    0.0.0.0:49154                  0.0.0.0:0            LISTENING        500      lsass.exe      1970-01-01 00:00:00 
0xee52d98  TCPv6    :::49154                       :::0                 LISTENING        500      lsass.exe      1970-01-01 00:00:00 
0x4b5c008  TCPv4    0.0.0.0:49170                  65.54.89.134:80      CLOSED           876      svchost.exe    1970-01-01 00:00:00 
0x9b3ca30  TCPv4    192.168.181.133:49167          192.168.181.2:80     CLOSED           876      svchost.exe    1970-01-01 00:00:00 
0xee8e0c8  TCPv4    0.0.0.0:49159                  65.54.89.134:80      CLOSED           876      svchost.exe    1970-01-01 00:00:00 
0xf78d468  TCPv4    0.0.0.0:49164                  65.54.89.135:80      CLOSED           876      svchost.exe    1970-01-01 00:00:00 
0x3165c8   UDPv4    0.0.0.0:0                      *:*                                   1056     svchost.exe    2010-07-06 22:40:01 
0x3165c8   UDPv6    :::0                           *:*                                   1056     svchost.exe    2010-07-06 22:40:01 
0xea9868   UDPv4    127.0.0.1:1900                 *:*                                   1920     svchost.exe    2010-07-06 22:33:18 
0x12d6738  UDPv4    0.0.0.0:0                      *:*                                   1140     svchost.exe    2010-07-06 22:31:23 
0x12d6738  UDPv6    :::0                           *:*                                   1140     svchost.exe    2010-07-06 22:31:23
[snip]
}}}

= Registry =

Volatility is the only memory forensics framework with the ability to carve registry data. For more information, see BDG's [http://moyix.blogspot.com/2009/01/memory-registry-tools.html Memory Registry Tools] and [http://moyix.blogspot.com/2009/01/registry-code-updates.html Registry Code Updates]. 

== hivescan ==

To find the physical addresses of CMHIVEs (registry hives) in memory, use the hivescan command. You would take the output of this command and feed it to the hivelist. For more information, see BDG's [http://moyix.blogspot.com/2008/02/enumerating-registry-hives.html Enumerating Registry Hives].

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp hivescan
Volatile Systems Volatility Framework 1.4_rc1
Offset          (hex)          
1493000         0x0016c808
37018064        0x0234d9d0
66253488        0x03f2f2b0
73746896        0x046549d0
86327304        0x05254008
148837272       0x08df1398
148838864       0x08df19d0
153573840       0x092759d0
[snip]
}}}

== hivelist ==

To locate the virtual addresses of registry hives in memory, and the full paths to the corresponding hive on disk, use the hivelist command. Feed it any of the values output by hivescan. 

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp hivelist -o 0x0016c808
Volatile Systems Volatility Framework 1.4_rc1
Virtual     Physical    Name
0x99f0d008  0x0da7d008  \??\C:\Windows\ServiceProfiles\LocalService\NTUSER.DAT
0x9c1692b0  0x03f2f2b0  \??\C:\Users\admin\ntuser.dat
0x9c7dc5c8  0x0d46d5c8  \??\C:\Users\admin\AppData\Local\Microsoft\Windows\UsrClass.dat
0x9cc839d0  0x046549d0  \??\C:\Windows\System32\SMI\Store\Machine\SCHEMA.DAT
0x82baa140  0x02baa140  [no name]
0x8780c008  0x0ac97008  [no name]
0x878197b8  0x0ab5e7b8  \REGISTRY\MACHINE\SYSTEM
0x878419d0  0x0a7489d0  \REGISTRY\MACHINE\HARDWARE
0x8c089398  0x08df1398  \SystemRoot\System32\Config\SOFTWARE
0x8c0899d0  0x08df19d0  \SystemRoot\System32\Config\SECURITY
0x8c18f9d0  0x092759d0  \SystemRoot\System32\Config\DEFAULT
0x8e23e008  0x05254008  \SystemRoot\System32\Config\SAM
0x980e75e0  0x0dccd5e0  \??\C:\Windows\System32\config\COMPONENTS
0x984709d0  0x0234d9d0  \Device\HarddiskVolume1\Boot\BCD
0x99e22808  0x0016c808  \??\C:\System Volume Information\Syscache.hve
[snip]
}}}

== printkey ==

To display the subkeys, values, data, and data types contained within a specified registry key, use the printkey command. It accepts a virtual address to the hive in which you want to search for a key. For example, to see the contents of HKEY_LOCAL_MACHINE, do the following:

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp printkey -o 0x8c089398 
Volatile Systems Volatility Framework 1.4_rc1
Key name: CMI-CreateHive{3D971F19-49AB-4000-8D39-A6D9C673D809}
(Stable)
Last updated: 2010-03-10 22:48:38 

Subkeys:
  AccessData(Stable)
  BreakPoint(Stable)
  Classes(Stable)
  Clients(Stable)
  Foxit Software(Stable)
  Intel(Stable)
  Microsoft(Stable)
  Mozilla(Stable)
  mozilla.org(Stable)
[snip]
}}}

Now say you want to traverse into the HKEY_LOCAL_MACHINE\Microsoft\Security Center\Svc key. You can do that:

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp printkey -o 0x8c089398 -K 'Microsoft\Security Center\Svc'
Volatile Systems Volatility Framework 1.4_rc1
Key name: Svc
(Stable)
Last updated: 2010-07-06 22:33:20 

Subkeys:

Values:
REG_QWORD VistaSp1   : 128920209537502489 (Stable)
REG_DWORD AntiVirusOverride : 0 (Stable)
REG_DWORD AntiSpywareOverride : 0 (Stable)
REG_DWORD FirewallOverride : 0 (Stable)
}}}

== hivedump ==

To recursively list all subkeys in a hive, use the hivedump command and pass it the virtual address to the desired hive. 

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp hivedump -o 0x8e23e008
2010-03-09 19:50:19  \CMI-CreateHive{899121E8-11D8-44B6-ACEB-301713D5ED8C}\SAM\Domains\Builtin\Aliases\Names
2010-03-09 19:50:19  \CMI-CreateHive{899121E8-11D8-44B6-ACEB-301713D5ED8C}\SAM\Domains\Builtin\Aliases\Names\Administrators
2010-03-09 19:50:19  \CMI-CreateHive{899121E8-11D8-44B6-ACEB-301713D5ED8C}\SAM\Domains\Builtin\Aliases\Names\Backup Operators
2010-03-09 19:50:19  \CMI-CreateHive{899121E8-11D8-44B6-ACEB-301713D5ED8C}\SAM\Domains\Builtin\Aliases\Names\Cryptographic Operators
2010-03-09 19:50:19  \CMI-CreateHive{899121E8-11D8-44B6-ACEB-301713D5ED8C}\SAM\Domains\Builtin\Aliases\Names\Distributed COM Users
2010-03-09 19:50:19  \CMI-CreateHive{899121E8-11D8-44B6-ACEB-301713D5ED8C}\SAM\Domains\Builtin\Aliases\Names\Event Log Readers
2010-03-09 19:50:19  \CMI-CreateHive{899121E8-11D8-44B6-ACEB-301713D5ED8C}\SAM\Domains\Builtin\Aliases\Names\Guests
2010-03-09 19:50:19  \CMI-CreateHive{899121E8-11D8-44B6-ACEB-301713D5ED8C}\SAM\Domains\Builtin\Aliases\Names\IIS_IUSRS
2010-03-09 19:50:19  \CMI-CreateHive{899121E8-11D8-44B6-ACEB-301713D5ED8C}\SAM\Domains\Builtin\Aliases\Names\Network Configuration Operators
2010-03-09 19:50:19  \CMI-CreateHive{899121E8-11D8-44B6-ACEB-301713D5ED8C}\SAM\Domains\Builtin\Aliases\Names\Performance Log Users
2010-03-09 19:50:19  \CMI-CreateHive{899121E8-11D8-44B6-ACEB-301713D5ED8C}\SAM\Domains\Builtin\Aliases\Names\Performance Monitor Users
2010-03-09 19:50:19  \CMI-CreateHive{899121E8-11D8-44B6-ACEB-301713D5ED8C}\SAM\Domains\Builtin\Aliases\Names\Power Users
2010-03-09 19:50:19  \CMI-CreateHive{899121E8-11D8-44B6-ACEB-301713D5ED8C}\SAM\Domains\Builtin\Aliases\Names\Remote Desktop Users
2010-03-09 19:50:19  \CMI-CreateHive{899121E8-11D8-44B6-ACEB-301713D5ED8C}\SAM\Domains\Builtin\Aliases\Names\Replicator
2010-03-09 19:50:19  \CMI-CreateHive{899121E8-11D8-44B6-ACEB-301713D5ED8C}\SAM\Domains\Builtin\Aliases\Names\Users
[snip]
}}}

== hashdump ==

To extract and decrypt cached domain credentials stored in the registry, use the hashdump command. For more information, see BDG's [http://moyix.blogspot.com/2008/02/cached-domain-credentials.html Cached Domain Credentials] and [http://www.slideshare.net/mooyix/sans-forensics-2009-memory-forensics-and-registry-analysis SANS Forensics 2009 - Memory Forensics and Registry Analysis].

To use hashdump, pass the virtual address of the SYSTEM hive as -y and the virtual address of the SAM hive as -s, like this:

{{{
$ volatility hashdump -f image.dd -y 0xe1035b60 -s 0xe165cb60 Administrator:500:08f3a52bdd35f179c81667e9d738c5d9:ed88cccbc08d1c18bcded317112555f4::: Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: HelpAssistant:1000:ddd4c9c883a8ecb2078f88d729ba2e67:e78d693bc40f92a534197dc1d3a6d34f::: SUPPORT_388945a0:1002:aad3b435b51404eeaad3b435b51404ee:8bfd47482583168a0ae5ab020e1186a9::: phoenix:1003:07b8418e83fad948aad3b435b51404ee:53905140b80b6d8cbe1ab5953f7c1c51::: ASPNET:1004:2b5f618079400df84f9346ce3e830467:aef73a8bb65a0f01d9470fadc55a411c::: S----:1006:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: 
}}}

Hashes can now be cracked using John the Ripper, rainbow tables, etc. 

== lsadump ==

To dump LSA secrets from the registry, use the lsadump command. This exposes information such as the default password (for systems with autologin enabled), the RDP public key, and credentials used by DPAPI.

For more information, see BDG's [http://moyix.blogspot.com/2008/02/decrypting-lsa-secrets.html Decrypting LSA Secrets].

To use lsadump, pass the virtual address of the SYSTEM hive as the -y parameter and the virtual address of the SECURITY hive as the -s parameter. 

{{{
$ python volatility.py -f laqma.vmem lsadump -y 0xe1035b60 -s 0xe16a6b60
Volatile Systems Volatility Framework 1.4_rc1
L$RTMTIMEBOMB_1320153D-8DA3-4e8e-B27B-0D888223A588

0000   00 92 8D 60 01 FF C8 01                            ...`....

_SC_Dnscache

L$HYDRAENCKEY_28ada6da-d622-11d1-9cb9-00c04fb16e75

0000   52 53 41 32 48 00 00 00 00 02 00 00 3F 00 00 00    RSA2H.......?...
0010   01 00 01 00 37 CE 0C C0 EF EC 13 C8 A4 C5 BC B8    ....7...........
0020   AA F5 1A 7C 50 95 A4 E9 3B BA 41 C8 53 D7 CE C6    ...|P...;.A.S...
0030   CB A0 6A 46 7C 70 F3 21 17 1C FB 79 5C C1 83 68    ..jF|p.!...y...h
0040   91 E5 62 5E 2C AC 21 1E 79 07 A9 21 BB F0 74 E8    ..b^,.!.y..!..t.
0050   85 66 F4 C4 00 00 00 00 00 00 00 00 F9 D7 AD 5C    .f..............
0060   B4 7C FB F6 88 89 9D 2E 91 F2 60 07 10 42 CA 5A    .|........`..B.Z
0070   FC F0 D1 00 0F 86 29 B5 2E 1E 8C E0 00 00 00 00    ......).........
0080   AF 43 30 5F 0D 0E 55 04 57 F9 0D 70 4A C8 36 01    .C0_..U.W..pJ.6.
0090   C2 63 45 59 27 62 B5 77 59 84 B7 65 8E DB 8A E0    .cEY'b.wY..e....
00A0   00 00 00 00 89 19 5E D8 CB 0E 03 39 E2 52 04 37    ......^....9.R.7
00B0   20 DC 03 C8 47 B5 2A B3 9C 01 65 15 FF 0F FF 8F     ...G.*...e.....
00C0   17 9F C1 47 00 00 00 00 1B AC BF 62 4E 81 D6 2A    ...G.......bN..*
00D0   32 98 36 3A 11 88 2D 99 3A EA 59 DE 4D 45 2B 9E    2.6:..-.:.Y.ME+.
00E0   74 15 14 E1 F2 B5 B2 80 00 00 00 00 75 BD A0 36    t...........u..6
00F0   20 AD 29 0E 88 E0 FD 5B AD 67 CA 88 FC 85 B9 82     .)....[.g......
0100   94 15 33 1A F1 65 45 D1 CA F9 D8 4C 00 00 00 00    ..3..eE....L....
0110   71 F0 0B 11 F2 F1 AA C5 0C 22 44 06 E1 38 6C ED    q........"D..8l.
0120   6E 38 51 18 E8 44 5F AD C2 CE 0A 0A 1E 8C 68 4F    n8Q..D_.......hO
0130   4D 91 69 07 DE AA 1A EC E6 36 2A 9C 9C B6 49 1F    M.i......6*...I.
0140   B3 DD 89 18 52 7C F8 96 4F AF 05 29 DF 17 D8 48    ....R|..O..)...H
0150   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
0160   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
0170   00 00 00 00 00 00 00 00 00 00 00 00                ............

DPAPI_SYSTEM

0000   01 00 00 00 24 04 D6 B0 DA D1 3C 40 BB EE EC 89    ....$.....<@....
0010   B4 BB 90 5B 9A BF 60 7D 3E 96 72 CD 9A F6 F8 BE    ...[..`}>.r.....
0020   D3 91 5C FA A5 8B E6 B4 81 0D B6 D4                ............
}}}

= Crash Dumps, Hibernation, and Conversion =

== crashdump ==
== crashinfo ==
== hibdump ==
== hibinfo ==
== imagecopy ==

= Malware and Rootkits =

Although all Volatility commands can help you hunt malware in one way or another, there are a few designed specifically for hunting rootkits and malicious code. The most comprehensive documentation for these commands can be found in the [http://www.amazon.com/dp/0470613033 Malware Analyst's Cookbook and DVD: Tools and Techniques For Fighting Malicious Code].

When possible, we use [http://code.google.com/p/volatility/wiki/FAQ#Are_there_any_public_memory_samples_available_that_I_can_use_for publicly available images] for the examples, so you can verify on your end.

== malfind ==

The malfind command has several purposes. You can use it to find hidden or injected code/DLLs in user mode memory, based on characteristics such as VAD tag and page permissions. You can also use it to locate any sequence of bytes, regular expressions, ANSI strings, or Unicode strings in user mode or kernel memory. 

Here is an example of using it to detect the presence of Zeus. The first memory segment (starting at 0x01600000) was detected because its executable and has a VadS tag...which means there is memory mapped file already occupying the space. Based on a disassembly of the data found at this address, it seems to contain some API hook trampoline stubs. 

The second memory segment (starting at 0x015D0000) was detected because it contained an executable that isn't listed in the PEB's module lists. A copy of the PE file was saved to hidden_dumps/explorer.exe.4a065d0.015d0000-015f5fff.dmp. This is an unpacked copy of the Zeus binary that was injected into explorer.exe. 

{{{
$ python volatility.py -f zeus.vmem malfind -p 1724 -D hidden_dumps/
Volatile Systems Volatility Framework 1.4_rc1
Name                 Pid    Start      End        Tag    Hits Protect
explorer.exe           1724 0x01600000 0x01600FFF VadS      0      6 (MM_EXECUTE_READWRITE)
Dumped to: hidden_dumps/explorer.exe.4a065d0.01600000-01600fff.dmp
0x01600000   b8 35 00 00 00 e9 cd d7 30 7b b8 91 00 00 00 e9    .5......0{......
0x01600010   4f df 30 7b 8b ff 55 8b ec e9 ef 17 c1 75 8b ff    O.0{..U......u..
0x01600020   55 8b ec e9 95 76 bc 75 8b ff 55 8b ec e9 be 53    U....v.u..U....S
0x01600030   bd 75 8b ff 55 8b ec e9 d6 18 c1 75 8b ff 55 8b    .u..U......u..U.
0x01600040   ec e9 14 95 bc 75 8b ff 55 8b ec e9 4f 7e bf 75    .....u..U...O~.u
0x01600050   8b ff 55 8b ec e9 0a 32 bd 75 8b ff 55 8b ec e9    ..U....2.u..U...
0x01600060   7d 61 bc 75 6a 2c 68 b8 8d 1c 77 e9 01 8c bc 75    }a.uj,h...w....u
0x01600070   8b ff 55 8b ec e9 c4 95 4b 70 8b ff 55 8b ec e9    ..U.....Kp..U...

Disassembly:
01600000: b835000000                       MOV EAX, 0x35
01600005: e9cdd7307b                       JMP 0x7c90d7d7
0160000a: b891000000                       MOV EAX, 0x91
0160000f: e94fdf307b                       JMP 0x7c90df63
01600014: 8bff                             MOV EDI, EDI
01600016: 55                               PUSH EBP
01600017: 8bec                             MOV EBP, ESP
01600019: e9ef17c175                       JMP 0x7721180d
0160001e: 8bff                             MOV EDI, EDI
01600020: 55                               PUSH EBP

explorer.exe           1724 0x015D0000 0x015F5FFF VadS      0      6 (MM_EXECUTE_READWRITE)
Dumped to: hidden_dumps/explorer.exe.4a065d0.015d0000-015f5fff.dmp
0x015d0000   4d 5a 90 00 03 00 00 00 04 00 00 00 ff ff 00 00    MZ..............
0x015d0010   b8 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00    ........@.......
0x015d0020   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
0x015d0030   00 00 00 00 00 00 00 00 00 00 00 00 d0 00 00 00    ................
0x015d0040   0e 1f ba 0e 00 b4 09 cd 21 b8 01 4c cd 21 54 68    ........!..L.!Th
0x015d0050   69 73 20 70 72 6f 67 72 61 6d 20 63 61 6e 6e 6f    is program canno
0x015d0060   74 20 62 65 20 72 75 6e 20 69 6e 20 44 4f 53 20    t be run in DOS 
0x015d0070   6d 6f 64 65 2e 0d 0d 0a 24 00 00 00 00 00 00 00    mode....$.......
}}}

Now let's say you wanted to search for a pattern in process memory. You can create a YARA rules file and pass it to malfind as --yara-rules. Or, if you're just looking for something simple, and only plan to do the search a few times, then you can specify the criteria on command line instead. Here are some examples:

Search for signatures defined in the file rules.yar, in any process

{{{
$ python volatility.py -f zeus.vmem malfind -D hidden_dumps --yara-rules=rules.yar
}}}

Search for a simple string in any process: 

{{{
$ python volatility.py -f zeus.vmem malfind -D hidden_dumps --yara-rules="simpleStringToFind"
}}}

Search for a byte pattern in kernel memory. This does not check the entire range of kernel memory, it only checks the memory that belongs to loaded kernel drivers. For example, TDL3 applies a hard-patch to atapi.sys on disk. In particular, it adds some shell code to the .rsrc section of the file, and then modifies the !AddressOfEntryPoint so that it points at the shell code. This is TDL3's main persistence method. One of the unique instructions in the shell code is cmp dword ptr [eax], ‘3LDT’ so I made a YARA signature from that. 

{{{
$ python volatility.py -f tdl3.dmp malfind --yara-rules=rules.yar -D hidden_dumps --kernel
Volatile Systems Volatility Framework 1.4_rc1
Name                 Pid    Start      End        Tag    Hits Protect
vmscsi.sys           -      0xF9DB8000 0xF9DBB000 -         1 -      (Unknown)
Hit: 8b00813854444c33755a
0xf9dba4c3   8b 00 81 38 54 44 4c 33 75 5a 8b 45 f4 05 fd 29    ...8TDL3uZ.E...)
0xf9dba4d3   b7 f0 50 b8 08 03 00 00 8b 80 00 00 df ff ff b0    ..P.............
0xf9dba4e3   00 01 00 00 b8 08 03 00 00 8b 80 00 00 df ff 8b    ................
0xf9dba4f3   40 04 8b 4d ec 03 41 20 ff d0 ff 75 e0 b8 08 03    @..M..A ...u....
0xf9dba503   00 00 8b 80 00 00 df ff ff b0 00 01 00 00 b8 08    ................
0xf9dba513   03 00 00 8b 80 00 00 df ff 8b 00 05 84 03 00 00    ................
0xf9dba523   ff d0 eb 10 8b 45 e0 8b 40 0c 89 45 e0 e9 66 fe    .....E..@..E..f.
0xf9dba533   ff ff 33 c0 c9 c2 08 00 5e f8 a8 f2 fe 63 ec d0    ..3.....^....c..
}}}

Search for a given byte pattern in a particular process:

{{{
$ python volatility.py -f zeus.vmem malfind -D hidden_dumps --yara-rules="{eb 90 ff e4 88 32 0d}" --pid=624
}}}

Search for a regular expression in a particular process:

{{{
$ python volatility.py -f zeus.vmem malfind -D hidden_dumps --yara-rules="/my(regular|expression{0,2})/" --pid=624
}}}

== svcscan ==

Volatility is the only memory forensics framework with the ability to list Windows services. To see which services are registered on your memory image, use the svcscan command. The output shows the process ID of each service (if its active and pertains to a usermode process), the service name, service display name, service type, and current status. It also shows the binary path for the registered service - which will be an EXE for usermode services and a driver name for services that run from kernel mode. 

The lanmandrv entry displayed below is the name of the service that Laqma installs to load its malicious kernel driver.

{{{
$ python volatility.py svcscan -f laqma.vmem
Volatile Systems Volatility Framework 1.4_rc1
Record       Order    Pid      Name             DisplayName                              Type                           State                Path

[snip]

0x6ea738     0xf5     1148     WebClient        WebClient                                SERVICE_WIN32_SHARE_PROCESS    SERVICE_RUNNING      C:\WINDOWS\system32\svchost.exe -k LocalService
0x6ea7c8     0xf6     1028     winmgmt          Windows Management Instrumentation       SERVICE_WIN32_SHARE_PROCESS    SERVICE_RUNNING      C:\WINDOWS\System32\svchost.exe -k netsvcs
0x6ea858     0xf7     -------- WmdmPmSN         Portable Media Serial Number Service     SERVICE_WIN32_SHARE_PROCESS    SERVICE_STOPPED      --------
0x6ea8e8     0xf8     -------- Wmi              Windows Management Instrumentation Driver Extensions SERVICE_WIN32_SHARE_PROCESS    SERVICE_STOPPED      --------
0x6ea970     0xf9     -------- WmiApSrv         WMI Performance Adapter                  SERVICE_WIN32_OWN_PROCESS      SERVICE_STOPPED      --------
0x6eaa00     0xfa     -------- WS2IFSL          Windows Socket 2.0 Non-IFS Service Provider Support Environment SERVICE_KERNEL_DRIVER          SERVICE_RUNNING      \Driver\WS2IFSL
0x6eaa90     0xfb     1028     wscsvc           Security Center                          SERVICE_WIN32_SHARE_PROCESS    SERVICE_RUNNING      C:\WINDOWS\System32\svchost.exe -k netsvcs
0x6eab20     0xfc     1028     wuauserv         Automatic Updates                        SERVICE_WIN32_SHARE_PROCESS    SERVICE_RUNNING      C:\WINDOWS\System32\svchost.exe -k netsvcs
0x6eabb0     0xfd     1028     WZCSVC           Wireless Zero Configuration              SERVICE_WIN32_SHARE_PROCESS    SERVICE_RUNNING      C:\WINDOWS\System32\svchost.exe -k netsvcs
0x6eac40     0xfe     -------- xmlprov          Network Provisioning Service             SERVICE_WIN32_SHARE_PROCESS    SERVICE_STOPPED      --------
0x6eacd0     0xff     -------- lanmandrv        lanmandrv                                SERVICE_KERNEL_DRIVER          SERVICE_RUNNING      \Driver\lanmandrv
}}}

== ldrmodules ==

There are many ways to hide a DLL. One of the ways involves unlinking the DLL from one (or all) of the linked lists in the PEB. However, when this is done, there is still information contained within the VAD (Virtual Address Descriptor) which identifies the base address of the DLL and its full path on disk. To cross-reference this information (known as memory mapped files) with the 3 PEB lists, use the ldrmodules command. 

For each memory mapped PE file, the ldrmodules command prints a 0 or a 1 if the PE exists in the PEB lists. 

{{{
$ python volatility.py -f laqma.vmem ldrmodules 
Volatile Systems Volatility Framework 1.4_rc1
Pid      Process              Base     InLoad   InInit   InMem    Path
   608 csrss.exe            0x010E0000      0      0      0 \WINDOWS\Fonts\vgasys.fon
   608 csrss.exe            0x75B60000      0      0      0 \WINDOWS\system32\winsrv.dll
   608 csrss.exe            0x77D40000      0      0      0 \WINDOWS\system32\user32.dll
   632 winlogon.exe         0x01000000      1      0      1 \WINDOWS\system32\winlogon.exe
   632 winlogon.exe         0x77DD0000      1      1      1 \WINDOWS\system32\advapi32.dll
   632 winlogon.exe         0x77D40000      1      1      1 \WINDOWS\system32\user32.dll
   676 services.exe         0x01000000      1      0      1 \WINDOWS\system32\services.exe
   676 services.exe         0x758E0000      1      1      1 \WINDOWS\system32\scesrv.dll
   688 lsass.exe            0x01000000      1      0      1 \WINDOWS\system32\lsass.exe
   936 svchost.exe          0x01000000      1      0      1 \WINDOWS\system32\svchost.exe
  1028 svchost.exe          0x01000000      1      0      1 \WINDOWS\system32\svchost.exe
  1028 svchost.exe          0x20000000      1      1      1 \WINDOWS\system32\xpsp2res.dll
  1028 svchost.exe          0x76D30000      1      1      1 \WINDOWS\system32\wmi.dll
  1028 svchost.exe          0x77F60000      1      1      1 \WINDOWS\system32\shlwapi.dll
[snip]
}}}

Since the PEB and the DLL lists that it contains all exist in user mode, its also possible for malware to hide (or obscure) a DLL by simply overwriting the path. Tools that only look for unlinked entries may miss the fact that malware overwrite C:\bad.dll to show C:\windows\system32\kernel32.dll. So you can also pass -v or --verbose to ldrmodules to see the full path of all entries:

{{{
$ python volatility.py -f laqma.vmem ldrmodules -v
Volatile Systems Volatility Framework 1.4_rc1
Pid      Process              Base     InLoad   InInit   InMem    Path

[snip]

  1028 svchost.exe          0x77C10000      1      1      1 \WINDOWS\system32\msvcrt.dll
  Load Path: C:\WINDOWS\system32\msvcrt.dll : msvcrt.dll
  Init Path: C:\WINDOWS\system32\msvcrt.dll : msvcrt.dll
  Mem Path:  C:\WINDOWS\system32\msvcrt.dll : msvcrt.dll
  1028 svchost.exe          0x76D10000      1      1      1 \WINDOWS\system32\clusapi.dll
  Load Path: C:\WINDOWS\System32\CLUSAPI.DLL : CLUSAPI.DLL
  Init Path: C:\WINDOWS\System32\CLUSAPI.DLL : CLUSAPI.DLL
  Mem Path:  C:\WINDOWS\System32\CLUSAPI.DLL : CLUSAPI.DLL
  1028 svchost.exe          0x76E80000      1      1      1 \WINDOWS\system32\rtutils.dll
  Load Path: c:\windows\system32\rtutils.dll : rtutils.dll
  Init Path: c:\windows\system32\rtutils.dll : rtutils.dll
  Mem Path:  c:\windows\system32\rtutils.dll : rtutils.dll
  1028 svchost.exe          0x71AA0000      1      1      1 \WINDOWS\system32\ws2help.dll
  Load Path: c:\windows\system32\WS2HELP.dll : WS2HELP.dll
  Init Path: c:\windows\system32\WS2HELP.dll : WS2HELP.dll
  Mem Path:  c:\windows\system32\WS2HELP.dll : WS2HELP.dll
[snip]
}}}

== impscan ==

In order to fully reverse engineer code that you find in memory dumps, its necessary to see which functions the code imports. In other words, which API functions it calls. When you dump binaries with dlldump, moddump, procexedump/procmemdump, it doesn't rebuild the IAT (Import Address Table) - many times the required memory pages are paged to disk. Thus, we created impscan. Impscan identifies calls to APIs without parsing a PE file's IAT. It even works if malware completely erases the PE header, and it works on kernel drivers. 

If you have IDA Pro installed, make sure idag.exe (Windows) or idal (Linux/OS X) is in your $PATH variable. If so, then impscan will automatically create a labeled IDB from the code you want to analyze. You can then open up the extracted code in IDA and begin reversing...

Take Conficker for example. This malware deleted its PE header once it loaded in the target process. You can use malfind to detect the presence of Conficker based on the typical malfind criteria (page permissions, VAD tags, etc). Notice how the PE's base address doesn't contain the usual 'MZ' header:

{{{
$ python volatility.py -f conficker.bin -p 3108 malfind -D out/
Volatile Systems Volatility Framework 1.4_rc1
Name                 Pid    Start      End        Tag    Hits Protect
notepad.exe            3108 0x00A10000 0x00A2BFFF VadS      0     24 (MM_EXECUTE_UNKNOWN)
Dumped to: out/services.exe.20c8558.00a10000-00a2bfff.dmp
0x00a10000   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
0x00a10010   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
0x00a10020   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
0x00a10030   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
0x00a10040   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
0x00a10050   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
0x00a10060   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
0x00a10070   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
}}}

Let's assume you want to extract the unpacked copy of Conficker and see its imported APIs. Use impscan by specifying the base address provided to you by malfind:

{{{
$ python volatility.py -f conficker.bin -p 3108 impscan -a 0x00A10000 -D out
Volatile Systems Volatility Framework 1.4_rc1
a11204 RPCRT4.dll NdrClientCall2 77ef44d0
a11208 RPCRT4.dll RpcStringBindingComposeA 77e9a8e4
a110ac kernel32.dll Process32First 7c864f55
a1120c RPCRT4.dll RpcBindingFromStringBindingA 77e9a898
a11210 RPCRT4.dll RpcBindingFree 77e7b3d8
a11058 kernel32.dll FreeLibrary 7c80ac7e
a11220 VERSION.dll VerQueryValueA 77c018aa
a110b0 kernel32.dll Process32Next 7c8650c8
a11224 VERSION.dll GetFileVersionInfoA 77c01a40
a11228 VERSION.dll GetFileVersionInfoSizeA 77c019ef
a11230 WININET.dll InternetOpenA 771c5796
a11034 kernel32.dll WriteFile 7c810e27
a11238 WININET.dll InternetReadFile 771c82f2
a1123c WININET.dll InternetCloseHandle 771c4d94
a11240 WININET.dll InternetGetConnectedState 771d5c8e
a11260 WS2_32.dll sendto 71ab2f51
a11244 WININET.dll InternetOpenUrlA 771c5a62
[snip]
}}}

If you don't specify a base address with -a or --address, then you'll end up scanning the process's main module (i.e. services.exe) for imported functions. You can also specify the base address of a kernel driver to scan the driver for imported kernel-mode functions. 

== apihooks ==

To find API hooks in user mode or kernel mode, use the apihooks plugin. This finds IAT, EAT, Inline style hooks, and several special types of hooks. For Inline hooks, it detects CALLs and JMPs to direct and indirect locations, and it detects PUSH/RET instruction sequences. The special types of hooks that it detects include syscall hooking in ntdll.dll and calls to unknown code pages in kernel memory.

Here is an example of detecting IAT hooks installed by Coreflood. The far right field contains UNKNOWN because there is no module associated with the memory in which the rootkit code exists. 

{{{
$ python volatility.py -f coreflood.vmem -p 2044 apihooks 
Volatile Systems Volatility Framework 1.4_rc1
Name                             Type     Target                                   Value
IEXPLORE.EXE[2044]@winspool.drv  iat      KERNEL32.dll!GetProcAddress              0x0 0x7ff82360 (UNKNOWN)
IEXPLORE.EXE[2044]@winspool.drv  iat      KERNEL32.dll!LoadLibraryW                0x0 0x7ff82ac0 (UNKNOWN)
IEXPLORE.EXE[2044]@winspool.drv  iat      KERNEL32.dll!CreateFileW                 0x0 0x7ff82240 (UNKNOWN)
IEXPLORE.EXE[2044]@winspool.drv  iat      KERNEL32.dll!LoadLibraryA                0x0 0x7ff82a50 (UNKNOWN)
IEXPLORE.EXE[2044]@winspool.drv  iat      ADVAPI32.dll!RegSetValueExW              0x0 0x7ff82080 (UNKNOWN)
[snip]
}}}

Here is an example of detecting the Inline hooks installed by Silentbanker:

{{{
$ python volatility.py -f silentbanker.vmem -p 1884 apihooks
Volatile Systems Volatility Framework 1.4_rc1
Name                             Type     Target                                   Value
IEXPLORE.EXE[1884]               inline   ws2_32.dll!connect                       0x71ab406a JMP 0xe90000 (UNKNOWN)
IEXPLORE.EXE[1884]               inline   ws2_32.dll!send                          0x71ab428a JMP 0xe70000 (UNKNOWN)
IEXPLORE.EXE[1884]               inline   user32.dll!DispatchMessageA              0x77d4bcbd JMP 0x10e0000 (UNKNOWN)
IEXPLORE.EXE[1884]               inline   user32.dll!DispatchMessageW              0x77d489d9 JMP 0x1100000 (UNKNOWN)
IEXPLORE.EXE[1884]               inline   user32.dll!GetClipboardData              0x77d6fcb2 JMP 0x10c0000 (UNKNOWN)
[snip]
}}}

Here is an example of detecting the PUSH/RET Inline hooks installed by Laqma:

{{{
$ python volatility.py -f laqma.vmem -p 1624 apihooks
Volatile Systems Volatility Framework 1.4_rc1
Name                             Type     Target                                   Value
explorer.exe[1624]               inline   user32.dll!MessageBoxA                   0x7e45058a PUSH 0xac10aa; RET (Dll.dll)
explorer.exe[1624]               inline   crypt32.dll!CertSerializeCRLStoreElement 0x77aa28df PUSH 0xac1104; RET (Dll.dll)
explorer.exe[1624]               inline   crypt32.dll!CertSerializeCTLStoreElement 0x77aa28df PUSH 0xac1104; RET (Dll.dll)
explorer.exe[1624]               inline   crypt32.dll!CertSerializeCertificateStoreElement 0x77aa28df PUSH 0xac1104; RET (Dll.dll)
explorer.exe[1624]               inline   crypt32.dll!PFXImportCertStore           0x77aef748 PUSH 0xac12a8; RET (Dll.dll)
explorer.exe[1624]               inline   wininet.dll!HttpOpenRequestA             0x771c36dd PUSH 0xac148c; RET (Dll.dll)
explorer.exe[1624]               inline   wininet.dll!HttpSendRequestA             0x771c6129 PUSH 0xac162c; RET (Dll.dll)
[snip]
}}}

Here is an example of using apihooks to detect the syscall patches in ntdll.dll (using a Carberp sample):

{{{
$ python volatility.py -f carberp.vmem apihooks
Volatile Systems Volatility Framework 1.4_rc1
Name                             Type     Target                                   Value
explorer.exe[1004]               inline   ntdll.dll!NtCreateThread                 0x7c90d190 JMP 0x15a3fa7 (UNKNOWN)
explorer.exe[1004]               inline   ntdll.dll!ZwCreateThread                 0x7c90d190 JMP 0x15a3fa7 (UNKNOWN)
explorer.exe[1004]               syscall  ntdll.dll!NtQueryDirectoryFile           0x1dadd84 MOV EDX, 0x1dadd84 (UNKNOWN)
explorer.exe[1004]               syscall  ntdll.dll!NtResumeThread                 0x1dadd78 MOV EDX, 0x1dadd78 (UNKNOWN)
explorer.exe[1004]               syscall  ntdll.dll!ZwQueryDirectoryFile           0x1dadd84 MOV EDX, 0x1dadd84 (UNKNOWN)
explorer.exe[1004]               syscall  ntdll.dll!ZwResumeThread                 0x1dadd78 MOV EDX, 0x1dadd78 (UNKNOWN)
explorer.exe[1004]               inline   ws2_32.dll!WSASend                       0x71ab68fa JMP 0x15a97f7 (UNKNOWN)
explorer.exe[1004]               inline   ws2_32.dll!closesocket                   0x71ab3e2b JMP 0x15a979e (UNKNOWN)
[snip]
}}}

Here is an example of using apihooks to detect the Inline hook of a kernel mode function:

{{{
$ python volatility.py apihooks -K -f rustock.vmem 

Name     Type     Function                        Value
-        inlinek  ntoskrnl.exe!IofCallDriver      0x804ee130 jmp [0x8054c280] =>> 0xb17a189d (\Driver\pe386)
}}}

Here is an example of using apihooks to detect the calls to an unknown code page from a kernel driver. In this case, malware has patched tcpip.sys with some malicious redirections. 

{{{
$ python volatility.py -f rustock-2.vmem apihooks -K
Volatile Systems Volatility Framework 1.4_rc1
Name                             Type     Target                                   Value
-                                ucpcall  tcpip.sys                                0xf7be2514 CALL [0x81ecd0c0]
-                                ucpcall  tcpip.sys                                0xf7be28ad CALL [0x81e9da60]
-                                ucpcall  tcpip.sys                                0xf7be2c61 CALL [0x81f8a058]
-                                ucpcall  tcpip.sys                                0xf7bfa0c0 CALL [0x82009dd0]
}}}

== idt ==

To print the system's IDT (Interrupt Descriptor Table), use the idt command. This displays the purpose of the interrupts, along with the current address and owning module. It also checks the IDT entries for Inline style API hooks. This is important because some rootkits hook the IDT entry for !KiSystemService, but point it at a routine inside the NT module (where !KiSystemService should point). However, at that address, there is an Inline hook!

{{{
$ python volatility.py idt -f rustock.vmem 

2A       KiGetTickCount             0x8053cbae   ntoskrnl.exe .text
2B       KiCallbackReturn           0x8053ccb0   ntoskrnl.exe .text
2C       KiSetLowWaitHighThread     0x8053ce50   ntoskrnl.exe .text
2D       KiDebugService             0x8053d790   ntoskrnl.exe .text
2E       KiSystemService            0x806b973c   ntoskrnl.exe .rsrc => jmp 0xf6ec0e19
[snip]
}}}

== orphanthreads ==

To detect kernel threads which don't map back to known kernel drivers, use the orphanthreads command. This works by scanning for ETHREAD objects and checking see if the thread's start address lands within a driver in the !PsLoadedModuleList linked list. If not, the thread has been "abandoned" - likely meaning that a driver loaded, started some threads, and then unlinked itself or unloaded. 

Here is an example of locating orphan threads on a machine infected with Tigger. As you can see, there are 4 threads identified, all owned by the PID 4 (System) process. The System process is the default owner of threads created by !PsCreateThread in kernel mode. One of the 4 has exited, but the others remain running. The starting addresses are in the range 0xf2XXXXXX however there is no driver in that space - meaning its likely the location of Tigger's hidden component. 

{{{
$ python volatility.py -f tigger.vmem orphanthreads
Volatile Systems Volatility Framework 1.4_rc1
PID    TID    Create Time               Exit Time                 Offset     StartAddress
------ ------ ------------------------- ------------------------- ---------- ------------
     4   1992 2010-08-15 19:26:13                                 0x010964a8 0xf2edba46
     4    600 2010-08-11 06:09:35       2010-08-11 06:09:35       0x0113e4a8 0xf2fe2150
     4   1720 2010-08-15 19:26:13                                 0x05e354a0 0xf2edc54e
     4   1648 2010-08-15 19:26:13                                 0x065a32b0 0xf2edd150
}}}

== notifyroutines ==

Volatility is the only memory forensics platform with the ability to print an assortment of important notification routines and kernel callbacks. Rootkits, anti-virus suites, dynamic analysis tools (such as Sysinternals' Process Monitor and Tcpview), and many components of the Windows kernel use of these callbacks to monitor and/or react to events. We detect the following:

  * !PsSetCreateProcessNotifyRoutine (process creation).
  * !PsSetCreateThreadNotifyRoutine (thread creation).
  * !PsSetImageLoadNotifyRoutine (DLL/image load).
  * !IoRegisterFsRegistrationChange (file system registration).
  * !KeRegisterBugCheck and !KeRegisterBugCheckReasonCallback.
  * !CmRegisterCallback (registry callbacks on XP).
  * !CmRegisterCallbackEx (registry callbacks on Vista and 7).
  * !IoRegisterShutdownNotification (shutdown callbacks).
  * !DbgSetDebugPrintCallback (debug print callbacks on Vista and 7).
  * !DbgkLkmdRegisterCallback (debug callbacks on 7).

Here's an example of detecting the thread creation callback installed by the !BlackEnergy 2 malware. You can spot the malicious callback because the owner is 00004A2A - and !BlackEnergy 2 uses a module name composed of eight hex characters. 

{{{
$ python volatility.py -f be2.vmem notifyroutines
Volatile Systems Volatility Framework 1.4_rc1
Type                                 Callback   Owner
PsSetCreateThreadNotifyRoutine       0xff0d2ea7 00004A2A
PsSetCreateProcessNotifyRoutine      0xfc58e194 vmci.sys
KeBugCheckCallbackListHead           0xfc1e85ed NDIS.sys (Ndis miniport)
KeBugCheckCallbackListHead           0x806d57ca hal.dll (ACPI 1.0 - APIC platform UP)
KeRegisterBugCheckReasonCallback     0xfc967ac0 mssmbios.sys (SMBiosData)
KeRegisterBugCheckReasonCallback     0xfc967a78 mssmbios.sys (SMBiosRegistry)
[snip]
}}}

Here is an example of detecting the malicious process creation callback installed by the Rustock rootkit (points to memory owned by \Driver\pe386).

{{{
$ python volatility.py -f rustock.vmem notifyroutines
Volatile Systems Volatility Framework 1.4_rc1
Type                                 Callback   Owner
PsSetCreateProcessNotifyRoutine      0xf88bd194 vmci.sys
PsSetCreateProcessNotifyRoutine      0xb17a27ed '\\Driver\\pe386'
KeBugCheckCallbackListHead           0xf83e65ef NDIS.sys (Ndis miniport)
KeBugCheckCallbackListHead           0x806d77cc hal.dll (ACPI 1.0 - APIC platform UP)
KeRegisterBugCheckReasonCallback     0xf8b7aab8 mssmbios.sys (SMBiosData)
KeRegisterBugCheckReasonCallback     0xf8b7aa70 mssmbios.sys (SMBiosRegistry)
KeRegisterBugCheckReasonCallback     0xf8b7aa28 mssmbios.sys (SMBiosDataACPI)
KeRegisterBugCheckReasonCallback     0xf76201be USBPORT.SYS (USBPORT)
KeRegisterBugCheckReasonCallback     0xf762011e USBPORT.SYS (USBPORT)
KeRegisterBugCheckReasonCallback     0xf7637522 VIDEOPRT.SYS (Videoprt)
[snip]
}}}

Here is an example of detecting the malicious registry change callback installed by the Ascesso rootkit. There is one !CmRegisterCallback pointing to 0x8216628f which does not have an owner. You also see two !GenericKernelCallback with the same address. This is because notifyroutines finds callbacks in multiple ways. It combines list traversal and pool tag scanning. This way, if the list traversal fails, we can still find information with pool tag scanning. However, the Windows kernel uses the same types of pool tags for various callbacks, so we label those as generic. 

{{{
$ python volatility.py -f ascesso.vmem notifyroutines
Volatile Systems Volatility Framework 1.4_rc1
Type                                 Callback   Owner
IoRegisterShutdownNotification       0xf853c2be ftdisk.sys (\Driver\Ftdisk)
IoRegisterShutdownNotification       0x805f5d66 ntoskrnl.exe (\Driver\WMIxWDM)
IoRegisterShutdownNotification       0xf83d98f1 Mup.sys (\FileSystem\Mup)
IoRegisterShutdownNotification       0xf86aa73a MountMgr.sys (\Driver\MountMgr)
IoRegisterShutdownNotification       0x805cdef4 ntoskrnl.exe (\FileSystem\RAW)
CmRegisterCallback                   0x8216628f UNKNOWN (--)
GenericKernelCallback                0xf888d194 vmci.sys
GenericKernelCallback                0x8216628f UNKNOWN
GenericKernelCallback                0x8216628f UNKNOWN
}}}

== driverirp ==

To print a driver's IRP (Major Function) table, use the driverirp command. This command inherits from driverscan so that its able to locate DRIVER_OBJECTs. Then it cycles through the function table, printing the purpose of each function, the function's address, and the owning module of the address. 

Many drivers forward their IRP functions to other drivers for legitimate purposes, so detecting hooked IRP functions based on containing modules is not a good method. Instead, we print everything and let you be the judge. The command also checks for Inline hooks of IRP functions and optionally prints a disassembly of the instructions at the IRP address (pass -v or --verbose to enable this). 

This command outputs information for all drivers, unless you specify a regular expression filter. 

{{{
$ python volatility.py -f tdl3.vmem driverirp -r vmscsi 
Volatile Systems Volatility Framework 1.4_rc1
DriverStart  Name             IRP                                  IrpAddr      IrpOwner         HookAddr     HookOwner
0xf9db8000   'vmscsi'         IRP_MJ_CREATE                        0xf9db9cbd   vmscsi.sys       -            -
0xf9db8000   'vmscsi'         IRP_MJ_CREATE_NAMED_PIPE             0xf9db9cbd   vmscsi.sys       -            -
0xf9db8000   'vmscsi'         IRP_MJ_CLOSE                         0xf9db9cbd   vmscsi.sys       -            -
0xf9db8000   'vmscsi'         IRP_MJ_READ                          0xf9db9cbd   vmscsi.sys       -            -
0xf9db8000   'vmscsi'         IRP_MJ_WRITE                         0xf9db9cbd   vmscsi.sys       -            -
0xf9db8000   'vmscsi'         IRP_MJ_QUERY_INFORMATION             0xf9db9cbd   vmscsi.sys       -            -
0xf9db8000   'vmscsi'         IRP_MJ_SET_INFORMATION               0xf9db9cbd   vmscsi.sys       -            -
0xf9db8000   'vmscsi'         IRP_MJ_QUERY_EA                      0xf9db9cbd   vmscsi.sys       -            -
0xf9db8000   'vmscsi'         IRP_MJ_SET_EA                        0xf9db9cbd   vmscsi.sys       -            -
[snip]
}}}

In the output, it is not apparent that the vmscsi.sys driver has been infected by the TDL3 rootkit. Although all IRPs point back into vmscsi.sys, they point at a stub staged in that region by TDL3 for the exact purpose of bypassing rootkit detection tools. To get extended information, use --verbose: 

{{{
$ python volatility.py -f tdl3.vmem driverirp -r vmscsi --verbose
Volatile Systems Volatility Framework 1.4_rc1
DriverStart  Name             IRP                                  IrpAddr      IrpOwner         HookAddr     HookOwner
0xf9db8000   'vmscsi'         IRP_MJ_CREATE                        0xf9db9cbd   vmscsi.sys       -            -
f9db9cbd: a10803dfff                       MOV EAX, [0xffdf0308]
f9db9cc2: ffa0fc000000                     JMP DWORD [EAX+0xfc]
f9db9cc8: 0000                             ADD [EAX], AL
f9db9cca: 0000                             ADD [EAX], AL
f9db9ccc: 0000                             ADD [EAX], AL

0xf9db8000   'vmscsi'         IRP_MJ_CREATE_NAMED_PIPE             0xf9db9cbd   vmscsi.sys       -            -
f9db9cbd: a10803dfff                       MOV EAX, [0xffdf0308]
f9db9cc2: ffa0fc000000                     JMP DWORD [EAX+0xfc]
f9db9cc8: 0000                             ADD [EAX], AL
f9db9cca: 0000                             ADD [EAX], AL
f9db9ccc: 0000                             ADD [EAX], AL
[snip]
}}}

Now you can see that TDL3 redirects all IRPs to its own stub in the vmscsi.sys driver. That code jumps to whichever address is pointed to by 0xffdf0308 - a location in the KUSER_SHARED_DATA region. 

== csrpslist ==

The CSRSS process contains some useful alternate process listings. In particular, it has a handle open to nearly every active process, and it also maintains an internal linked list of processes - separate from the one the kernel maintains. Thus, you can analyze data structures in the memory of csrss.exe and cross-reference them with what pslist finds. In fact, csrpslist does this all for you. On Windows Vista and Windows 7 the internal list of processes is not available. 

Here is an example of detecting the Prolaco malware with csrpslist. It generates all unique processes based on the !PsActiveProcessHead (pslist), the csrss.exe handle table, and the csrss.exe internal list. Then it loops through and prints which processes exist in which list. Any items which don't exist in the pslist (such as Pid 1336 below) have been hidden by a rootkit. 

{{{
$ python volatility.py -f prolaco.vmem csrpslist
Volatile Systems Volatility Framework 1.4_rc1
Name                 Pid    Pslist   Hndls    RootList
vmtoolsd.exe           1668        1        1        0
svchost.exe             856        1        1        0
spoolsv.exe            1432        1        1        0
svchost.exe            1028        1        1        0
smss.exe                544        1        0        0
TPAutoConnSvc.e        1968        1        1        0
services.exe            676        1        1        0
svchost.exe             936        1        1        0
lsass.exe               688        1        1        0
svchost.exe            1148        1        1        0
VMwareTray.exe          432        1        1        0
1_doc_RCData_61        1336        0        1        0
explorer.exe           1724        1        1        0
svchost.exe            1088        1        1        0
VMwareUser.exe          452        1        1        0
vmacthlp.exe            844        1        1        0
wscntfy.exe             888        1        1        0
wuauclt.exe             468        1        1        0
alg.exe                 216        1        1        0
csrss.exe               608        1        0        0
TPAutoConnect.e        1084        1        1        0
ImmunityDebugge        1136        1        1        0
winlogon.exe            632        1        1        0
VMUpgradeHelper        1788        1        1        0
System                    4        1        0        0
}}}

== ssdt_ex ==

If you want to explore SSDT hooks installed by rootkits, use the ssdt_ex command. This will automatically detect which SSDT functions are hooked, extract the hooking kernel driver to disk, and generate an IDC file (IDA script) containing labels for the rootkit functions. Then, if you have idag.exe (Windows) or idal (Linux/OS X) in your $PATH, then it will create an IDB file from the extracted kernel driver and run the IDC script. The result is a pre-labeled IDB for you to explore and reverse engineer, after typing just one command in Volatility.

Here is an example:

{{{
$ python volatility.py -f laqma.vmem ssdt_ex -D outdir/
Volatile Systems Volatility Framework 1.4_rc1
  Entry 0x0049: 0xf8c52884 (NtEnumerateValueKey) owned by lanmandrv.sys
  Entry 0x007a: 0xf8c5253e (NtOpenProcess) owned by lanmandrv.sys
  Entry 0x0091: 0xf8c52654 (NtQueryDirectoryFile) owned by lanmandrv.sys
  Entry 0x00ad: 0xf8c52544 (NtQuerySystemInformation) owned by lanmandrv.sys
Dumping IDC file to /Users/M/Desktop/Volatility-1.4_rc1/outdir/driver.f8c52000.sys.idc

[snip]
}}}

Now if you look in outdir, you'll find:

  * The extracted kernel driver (driver.f8c52000.sys)
  * The IDC script (driver.f8c52000.sys.idc)
  * The IDA database (driver.f8c52000.idb)

Inside the IDC script, you'll see something like this:

{{{
#include <idc.idc>
static main(void) {
   MakeFunction(0xF8C52A4C, BADADDR);
   MakeFunction(0xF8C52E7C, BADADDR);
   MakeName(0xF8C52544, "HookNtQuerySystemInformation");
   MakeFunction(0xF8C52544, BADADDR);
   MakeName(0xF8C52654, "HookNtQueryDirectoryFile");
   MakeFunction(0xF8C52654, BADADDR);
   MakeName(0xF8C52884, "HookNtEnumerateValueKey");
   MakeFunction(0xF8C52884, BADADDR);
   MakeName(0xF8C5253E, "HookNtOpenProcess");
   MakeFunction(0xF8C5253E, BADADDR);
Exit(0);
}
}}}

When you open the IDB, just navigate to any functions with a "Hook" prefix and you'll be staring at the rootkit's payload. 

== ssdt_by_threads ==

As mentioned in the documentation for the ssdt command, the SSDT is assigned on a per-thread basis. That means that one thread on a system may be calling through an SSDT with hooks installed by a rootkit, while other threads may be using a clean SSDT. To find out exactly which threads on a system are using a "tainted" view, use the ssdt_by_threads command. 

Here is an example of detecting the infected threads using a !BlackEnergy 2 sample. First you see the hooked SSDT functions and then a list of threads (found via thrdscan2). If a thread is using one of the hooked SSDTs, the command prints an exclamation mark by the thread info. As you can see, not all threads on the system are infected - only the ones which start *after* the rootkit driver loads get infected. 

{{{
$ python volatility.py -f be2.vmem ssdt_by_threads
Volatile Systems Volatility Framework 1.4_rc1
Pid      Tid      Name               SSDT      
  Entry 0x0041: 0xff0d2487 (NtDeleteValueKey) owned by 00004A2A
  Entry 0x0047: 0xff0d216b (NtEnumerateKey) owned by 00004A2A
  Entry 0x0049: 0xff0d2267 (NtEnumerateValueKey) owned by 00004A2A
  Entry 0x0077: 0xff0d20c3 (NtOpenKey) owned by 00004A2A
  Entry 0x007a: 0xff0d1e93 (NtOpenProcess) owned by 00004A2A
  Entry 0x0080: 0xff0d1f0b (NtOpenThread) owned by 00004A2A
  Entry 0x0089: 0xff0d2617 (NtProtectVirtualMemory) owned by 00004A2A
  Entry 0x00ad: 0xff0d1da0 (NtQuerySystemInformation) owned by 00004A2A
  Entry 0x00ba: 0xff0d256b (NtReadVirtualMemory) owned by 00004A2A
  Entry 0x00d5: 0xff0d2070 (NtSetContextThread) owned by 00004A2A
  Entry 0x00f7: 0xff0d2397 (NtSetValueKey) owned by 00004A2A
  Entry 0x00fe: 0xff0d201d (NtSuspendThread) owned by 00004A2A
  Entry 0x0102: 0xff0d1fca (NtTerminateThread) owned by 00004A2A
  Entry 0x0115: 0xff0d25c1 (NtWriteVirtualMemory) owned by 00004A2A
 
       4        8 System             0x80501030 
       4       12 System             0x80501030 
       4       16 System             0x80501030 
       4       20 System             0x80501030 

[snip

       4      312 System             0x80501030 
       4      252 System             0xFF3AAB90 [!]
       4      168 System             0xFF3AAB90 [!]
       4      248 System             0xFF3AAB90 [!]
     544      548 smss.exe           0x80501030 
     544      556 smss.exe           0x80501030 
     544      560 smss.exe           0x80501030 
     608      696 csrss.exe          0x80501030 
     608     1824 csrss.exe          0x80501030 
     608      812 csrss.exe          0x80501030 
     608      496 csrss.exe          0x80F162D0 [!]
     632      636 winlogon.exe       0x80501030 
     632      656 winlogon.exe       0x80501030 
     632      660 winlogon.exe       0x80501030 
     632      664 winlogon.exe       0x80501030 
     632      672 winlogon.exe       0x80501030 
     632      684 winlogon.exe       0x80501030 
[snip]
}}}

= Miscellaneous =

== strings ==
== volshell ==

If you want to interactively explore a memory image, use the volshell command. This gives you a WinDbg-like interface into the memory dump. For example, you can:

  * List processes
  * Switch into a process's context 
  * Display types of structures/objects
  * Overlay a type over a given address 
  * Walk linked lists 
  * Disassemble code at a given address

To break into a volshell:

{{{
$ python volatility.py --profile=Win7SP0x86 -f win7.dmp volshell
Volatile Systems Volatility Framework 1.4_rc1
Current context: process System, pid=4, ppid=0 DTB=0x185000
Welcome to volshell! Current memory image is:
file:///Users/M/Desktop/win7.dmp
To get help, type 'hh()'
>>> hh()
ps()                                     : Print a process listing.
cc(offset=None, pid=None, name=None)     : Change current shell context.
dd(address, length=128, space=None)      : Print dwords at address.
db(address, length=128, width=16, space=None) : Print bytes as canonical hexdump.
hh(cmd=None)                             : Get help on a command.
dt(objct, address=None)                  : Describe an object or show type info.
list_entry(head, objname, offset=-1, fieldname=None, forward=True) : Traverse a _LIST_ENTRY.
dis(address, length=128, space=None)     : Disassemble code at a given address.

For help on a specific command, type 'hh(<command>)'
>>> 
}}}

Let's say you want to see what's at 0x779f0000 in the memory of explorer.exe. First display the processes so you can get the PID or offset of Explorer's EPROCESS, like this:

{{{
>>> ps()
Name             PID    PPID   Offset  
System           4      0      0x83dad960
smss.exe         252    4      0x84e47840
csrss.exe        348    340    0x8d5ffd40
wininit.exe      384    340    0x84e6e3d8
csrss.exe        396    376    0x8d580530
winlogon.exe     424    376    0x8d598530
services.exe     492    384    0x8d4cc030
lsass.exe        500    384    0x8d6064a0
lsm.exe          508    384    0x8d6075d8
svchost.exe      616    492    0x8d653030
svchost.exe      680    492    0x8d673b88
svchost.exe      728    492    0x8d64fb38
taskhost.exe     1156   492    0x8d7ee030
dwm.exe          956    848    0x8d52bd40
explorer.exe     1880   1720   0x8d66c1a8
wuauclt.exe      1896   876    0x83ec3238
VMwareTray.exe   2144   1880   0x83f028d8
VMwareUser.exe   2156   1880   0x8d7893b0
[snip]
}}}

Now switch into Explorer's context and print the data with either db (display as canonical hexdump) or dd (display as double-words):

{{{
>>> dd(0x779f0000)
779f0000  00905a4d 00000003 00000004 0000ffff
779f0010  000000b8 00000000 00000040 00000000
779f0020  00000000 00000000 00000000 00000000
779f0030  00000000 00000000 00000000 000000e0
779f0040  0eba1f0e cd09b400 4c01b821 685421cd
779f0050  70207369 72676f72 63206d61 6f6e6e61
779f0060  65622074 6e757220 206e6920 20534f44
779f0070  65646f6d 0a0d0d2e 00000024 00000000
>>> db(0x779f0000)
779f0000   4d 5a 90 00 03 00 00 00 04 00 00 00 ff ff 00 00    MZ..............
779f0010   b8 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00    ........@.......
779f0020   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
779f0030   00 00 00 00 00 00 00 00 00 00 00 00 e0 00 00 00    ................
779f0040   0e 1f ba 0e 00 b4 09 cd 21 b8 01 4c cd 21 54 68    ........!..L.!Th
779f0050   69 73 20 70 72 6f 67 72 61 6d 20 63 61 6e 6e 6f    is program canno
779f0060   74 20 62 65 20 72 75 6e 20 69 6e 20 44 4f 53 20    t be run in DOS 
779f0070   6d 6f 64 65 2e 0d 0d 0a 24 00 00 00 00 00 00 00    mode....$.......
}}}

So there is a PE at 0x779f0000 in explorer.exe. If you want to disassemble instructions at RVA 0x2506 in the PE, do this:

{{{
>>> dis(0x779f0000 + 0x2506)
0x779f2506 8d0c48                           LEA ECX, [EAX+ECX*2]
0x779f2509 8b4508                           MOV EAX, [EBP+0x8]
0x779f250c 8b4c4802                         MOV ECX, [EAX+ECX*2+0x2]
0x779f2510 8d0448                           LEA EAX, [EAX+ECX*2]
0x779f2513 e9c07f0300                       JMP 0x77a2a4d8
0x779f2518 85f6                             TEST ESI, ESI
0x779f251a 0f85c12c0700                     JNZ 0x77a651e1
0x779f2520 8b4310                           MOV EAX, [EBX+0x10]
0x779f2523 8b407c                           MOV EAX, [EAX+0x7c]
0x779f2526 8b4b18                           MOV ECX, [EBX+0x18]
0x779f2529 0fb7444102                       MOVZX EAX, [ECX+EAX*2+0x2]
0x779f252e 894520                           MOV [EBP+0x20], EAX
[snip]
}}}

If you want to remind yourself of the members in an EPROCESS object for the given OS, do this:

{{{
>>> dt("_EPROCESS")
'_EPROCESS' (704 bytes)
0x0   : Pcb                            ['_KPROCESS']
0x98  : ProcessLock                    ['_EX_PUSH_LOCK']
0xa0  : CreateTime                     ['_LARGE_INTEGER']
0xa8  : ExitTime                       ['_LARGE_INTEGER']
0xb0  : RundownProtect                 ['_EX_RUNDOWN_REF']
0xb4  : UniqueProcessId                ['pointer', ['void']]
0xb8  : ActiveProcessLinks             ['_LIST_ENTRY']
0xc0  : ProcessQuotaUsage              ['array', 2, ['unsigned long']]
0xc8  : ProcessQuotaPeak               ['array', 2, ['unsigned long']]
0xd0  : CommitCharge                   ['unsigned long']
0xd4  : QuotaBlock                     ['pointer', ['_EPROCESS_QUOTA_BLOCK']]
[snip]
}}}

To overlay the EPROCESS types onto the offset for explorer.exe, do this:

{{{
>>> dt("_EPROCESS", 0x8d66c1a8)
[_EPROCESS _EPROCESS] @ 0x8D66C1A8
0x0   : Pcb                            2372321704
0x98  : ProcessLock                    2372321856
0xa0  : CreateTime                     2010-07-06 22:38:07 
0xa8  : ExitTime                       1970-01-01 00:00:00 
0xb0  : RundownProtect                 2372321880
0xb4  : UniqueProcessId                1880
0xb8  : ActiveProcessLinks             2372321888
0xc0  : ProcessQuotaUsage              -
0xc8  : ProcessQuotaPeak               -
0xd0  : CommitCharge                   4489
0xd4  : QuotaBlock                     2372351104
[snip]
}}}

For more information, see BDG's [http://moyix.blogspot.com/2008/08/indroducing-volshell.html Introducing Volshell]. 

== bioskbd ==
== inspectcache ==
== patcher ==
== testsuite ==