#summary Introduction to Volatility
#labels Featured

= Quick Start = 

  # *Choose a release* - the most recent is [Release22] (Volatility 2.2), released October 2012. Older versions are also available on the [http://code.google.com/p/volatility/downloads/list Downloads] page or respective release pages. If you want the cutting edge development build, use an svn client and [http://code.google.com/p/volatility/source/checkout checkout trunk]. 
  # *Install the code* - Volatility is packaged in several formats, including source code in zip or tar archive (all platforms), a Pyinstaller executable (Windows only) and a standalone executable (Windows only). For help deciding which format is best for your needs, and for installation or upgrade instructions, see VolatilityInstallation.
  # *Target OS specific setup* - the Linux, Mac, and Andoid support may require accessing symbols and building your own profiles before using volatility. If you plan to analyze these operating systems, please see LinuxMemoryForensics, MacMemoryForensics, or AndroidMemoryForensics.
  # *Read usage and plugins* - command-line parameters, options, and plugins may differ between releases. Thus, each release has a basic usage page and a command reference. For Volatility 2.2, see VolatilityUsage22 and CommandReference22. 
  # *Communicate* - If you have documentation, patches, ideas, or bug reports, you can communicate them through the  [http://code.google.com/p/volatility/issues/list Google Code web interface], IRC (#volatility on freenode), the [http://lists.volatilesystems.com/mailman/listinfo Volatility Mailing List], or Twitter ([https://twitter.com/volatility @volatility]). 
  # *Develop* - For advanced users who want to develop their own plugins, address spaces, and other components of volatility, there is a recommended StyleGuide and API documentation for each release (see DeveloperGuide22 for the most recent version).

= Why Volatility =

  * *A single, cohesive framework* analyzes RAM dumps from 32- and 64-bit windows, linux, mac, and android systems. Volatility's modular design allows it to easily support new operating systems and architectures as they are released. All your devices are targets...so don't limit your forensic capabilities to just windows computers. 

||[https://lh5.googleusercontent.com/-5BCvwpXxW5Y/UEpGD2N3rNI/AAAAAAAACrs/NxS8KP86a1M/s128/windows.jpeg]||[https://lh6.googleusercontent.com/-sJNFyoSK4V0/UEpGDh_ZVqI/AAAAAAAACrg/4EV92khpGcY/s128/apple.png]||[https://lh3.googleusercontent.com/-wVClF1ApCQ8/UEpGDoviGuI/AAAAAAAACr0/UmStpHxmDQ0/s128/linux.png]||[https://lh6.googleusercontent.com/-YiPFruxD_Gc/UEpGDj7RcqI/AAAAAAAACrk/f4EEjWmqREQ/s128/android.gif]||

  * *Its Open Source GPLv2*, which means you can read it, learn from it, and extend it. Why use a tool that outputs results without giving you any indication where the values came from or how they were interpreted? Learn how your tools work, understand why and how to tweak and enhance them - help yourself become a smarter analyst. You can also immediately fix any issues you discover, instead of having to wait weeks or months for vendors to communicate, reproduce, and publish patches.
  * *Its written in Python*, an established forensic and reverse engineering language with loads of libraries that can easily integrate into volatility. Most analysts are already familiar with Python and don't want to learn new languages. For example, windbg's scripting syntax which is often seen as cryptic and many times the capabilities just aren't there. Other memory analysis frameworks require you to use Visual Studio to compile C# DLLs and the rest don't expose a programming API at all.  
  * *Runs on windows, linux, or mac* analysis systems (anywhere Python runs) - a refreshing break from other memory analysis tools that only run on windows and require .NET installations and admin privileges just to open. If you're already accustomed to performing forensics on a particular host OS, by all means keep using it - and take volatility with you. 
  * *Extensible and scriptable API* gives you the power to go beyond and continue innovating. For example you can use volatility to build a customized web interface or GUI, drive your malware sandbox, perform virtual machine introspection or just explore kernel memory in an automated fashion. Analysts can add new address spaces, plugins, data structures, and overlays to truly weld the framework to their needs. 
  * *Unparalleled feature sets* based on reverse engineering and specialized research. Volatility provides capabilities that Microsoft's own kernel debugger doesn't allow, such as carving command histories, console input/output buffers, USER objects (GUI memory), and network related data structures. Just because its not documented doesn't mean you can't analyze it! 
  * *Comprehensive coverage of file formats* - volatility can analyze raw dumps, crash dumps, hibernation files, VMware .vmem, VMware saved state and suspended files (.vmss/.vmsn), !VirtualBox core dumps, LiME (Linux Memory Extractor), expert witness (EWF), and direct physical memory over Firewire. You can even convert back and forth between these formats. In the heat of your incident response moment, don't get caught looking like a fool when someone hands you a format your other tools can't parse. 
  * *Fast and efficient algorithms* let you analyze RAM dumps from large systems without unnecessary overhead or memory consumption. For example volatility is able to list kernel modules from an 80 GB system in just a few seconds. There is always room for improvement, and timing differs per command, however other memory analysis frameworks can take several hours to do the same thing on much smaller memory dumps.
  * *Serious and powerful community* of practitioners and researchers who work in the forensics, IR, and malware analysis fields. It brings together contributors from commercial companies, law enforcement, and academic institutions around the world. Don't just take our word for it - check out the VolatilityDocumentationProject - a collection of over 200 docs from 60+ different authors. Volatility is also being built on by a number of large organizations such as Google, National DoD Laboratories, DC3, and many Antivirus and security shops.
  * *Forensics/IR/malware focus* - Volatility was designed by forensics, incident response, and malware experts to focus on the types of tasks these analysts typically form. As a result, there are things that are often very important to a forensics analysts that are not as important to a person debugging a kernel driver (unallocated storage, indirect artifacts, etc). 
  * *Money-back guarantee* - although volatility is free, we stand by our work. There is nothing another memory analysis framework can do that volatility can't (or that it can't be quickly programmed to do). 

= Windows Features = 

  * *Basic / Informational* 
    * Current date, time, CPU count, CPU speed, service pack
    * Current thread and idle thread
    * Addresses of the KDBG, KPCR, DTB, !PsActiveProcessHead, !PsLoadedModuleList, etc
  * *Processes* 
    * List active processes (column or tree view)
    * Scan for hidden or terminated `_EPROCESS` objects (using pool tags or `_DISPATCHER_HEADER`)
    * Enumerate DLLs in the PEB LDR lists
    * Rebuild/extract DLLs or EXEs to disk based on name, base address, or physical offset
    * Print open handles to files, registry keys, mutexes, threads, processes, etc 
    * List security identifiers (SIDs) for processes 
    * Scan for cmd.exe command history and full console input/output buffers 
    * List process environment variables 
    * Print PE version information from processes or DLLs (file version, company name, etc)
    * Enumerate imported and exported API functions anywhere in process or kernel memory
    * Show a list of virtual and physical mappings of all pages available to a process
    * Dump process address space to disk as a single file
    * Analyze Virtual Address Descriptor (VAD) nodes, show page protection, flags, and mapped files
    * Represent the VAD in tree form or Graphviz .dot graphs
    * Dump each VAD range to disk for inspecting with external tools
    * Parse XP/2003 event log records 
  * *Kernel Memory* 
    * List loaded kernel modules and scan for hidden/unloaded module structures
    * Extract PE files including drivers from anywhere in kernel memory
    * Dump the SSDT for all 32- and 64-bit windows systems
    * Scan for driver objects, print IRP major function tables
    * Show devices and device tree layout
    * Scan for file objects (can show deleted files, closed handles, etc)
    * Scan for threads, mutex objects and symbolic links
  * *GUI Memory* 
    * Analyze logon sessions and the processes and mapped images belonging to the session
    * Scan for window stations and clipboard artifacts (clipboard snooping malware)
    * Scan for desktops, analyze desktop heaps and attached GUI threads
    * Locate and parse atom tables (class names, DLL injection paths, etc)
    * Extract the contents of the windows clipboard 
    * Analyze message hooks and event hooks, show the injected DLL and function address
    * Dump all USER object types, pool tags, and flags from the gahti 
    * Print all open USER handles, associated threads or processes, and object offsets
    * Display details on all windows, such as coordiates, window title, class, procedure address, etc
    * Take screen shots from memory dumps (requires PIL)
  * *Malware Analysis* 
    * Find injected code and DLLs, unpacker stubs, and decrypted configurations, etc
    * Scan process or kernel memory for any string, regular expression, byte pattern, URL, etc
    * Analyze services, their status (running, stopped, etc) and associated process or driver
    * Cross-reference memory mapped executable files with PEB lists to find injected code
    * Scan for imported functions in process or kernel memory (without using import tables)
    * Detect API hooks (Inline, IAT, EAT), hooked winsock tables, syscall hooks, etc
    * Analyze the IDT and GDT for each CPU, alert on hooks and disassemble code
    * Dump details of threads, such as hardware breakpoints, context registers, etc
    * Enumerate kernel callbacks for process creation, thread creation, and image loading
    * Display FS registration, registry, shutdown, bugcheck, and debug print callbacks
    * Detect hidden processes with alternate process listings (6+ sources)
    * Analyze kernel timers and their DPC routine functions
  * *Networking* 
    * Walk the list of connection and socket objects for XP/2003 systems
    * Scan physical memory for network information (recover closed/terminated artifacts)
    * Determine if listening sockets are IPv4, IPv6, etc and link to their owning processes
  * *Registry* 
    * Scan for registry hives in memory 
    * Parse and print any value or key cached in kernel memory, with timestamps
    * Dump an entire registry hive recursively 
    * Extract cached domain credentials from the registry
    * Locate and decrypt NT/NTLM hashes and LSA secrets 
    * Analyze user assist keys, the shimcache, and shellbags
  * *Crash Dumps, Hibernation, Conversion* 
    * Print crash dump and hibernation file header information
    * Run any plugin on a crash dump or hibernation file (hiberfil.sys)
    * Convert a raw memory dump to a crash dump for opening in !WinDBG
    * Convert a crash dump or hibernation file to a raw memory dump
  * *Miscellaneous* 
    * Link strings found at physical offsets to their owning kernel address or process
    * Interactive shell with disassembly, type display, hexdumps, etc