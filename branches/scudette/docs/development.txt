Volatility Technology Preview Developer information
===================================================
Michael Cohen <scudette@gmail.com>
September 2012
:toc2:
:icons:
:numbered:


Volatility is a powerful framework with many components. It is not necessary to
be intimately familiar with all components to be able to contribute. This
document attempts to cover as much internal API information as possible, but if
you already have a good idea of what you wish to accomplish, the
<<overview,Overview>> section will direct new users to the most relevant
section.

[[overview]]
Overview
--------

The following usage examples are typical areas where people would like to
contribute:

Adding support to a new image format::
 You will probably want to add a new address space by reading
 <<as,Address Spaces>>.

Using volatility as a library::
 You will want to read the section <<library,Using Volatility as a Libarary>>.

I want to add new functionality::
 If your code will be useful to all Volatility users and you would like to
 contribute it upstream you might want to read <<commands,Command Plugins>>, else
 you might want to write a standalone script and read <<library,Using Volatility
 as a Libarary>>.

[[commands]]
Plugins and Commands.
---------------------

Volatility is a modular framework. This means that most of the functionality of
the framework is implemented by plugins, enabling the framework to support
multiple operating systems. Even when using volatility as a library it is easy
to extend the library from within your own code (i.e. plugins do not need to be
embedded in the library itself).

A plugin is simply a piece of python code which declares a class extending one
of the special classes providing some kind of functionality. For example to
create a new address space, one simply defines a class extending
BaseAddressSpace. Once that happens, the framework automatically knows about
this new class and can use it e.g. in address space voting (there is no need to
call any initialization functions).

Plugins auto-register to the baseclass by means of a python metaclass. This
places a reference to all plugins of the same class in a class variable called
'classes'. This mechanism provides a simple way for one plugin to access another
plugin without needing to explicitly import its module.


Command Plugin
~~~~~~~~~~~~~~

A command is a reusable plugin which implements a user runnable command. For
example, when the user issues the 'pslist' command, the WinPSList plugin is
run. Therefore in order to be accessible to the user, a command plugin must
extend the plugin.Command class.

However it is not sufficient to simply extend the plugin.Command class, the
class must also declare what the name of the command it implements is. For
example the WinPSList class implements the 'pslist' command.

At any given moment there can be a number of command plugins which define a
particular user command. For example, LinPSList, WinPSList and MacPSList all
define a command called 'pslist'. The correct class to run is chosen based on
the profile.

Here is the base minimum that should be defined for a new command plugin:

`args(cls, parser)`::
  This is a classmethod called in order to construct the command line
  options. See below.

`__init__(**args)`::
  This is the constructor which should take any parameters you wish to
  accept. If you also want the user to be able to provide these parameters
  through the command line you will need to add them to the parser provided in
  args() above.

`is_active(cls, session)`::
  This method will be called with the session to check if this specific class is
  active. This mechanism allows multiple implementations to all share the same
  name, as long as only one is actually active. For example, we can have a
  linux, windows and mac version of plugins with the same "pslist" name.

`render(renderer)`::
  This is the main entry point for the command when called from the Volatility
  UI. The plugin should render any output using the renderer (see
  <<renderer,Rendering Output>>).


In addition to these methods the plugin should define any other methods that can
be reusable by other components.


Command line Invocation
~~~~~~~~~~~~~~~~~~~~~~~

So what happens when a user invokes volatility from the command line? Assume the
following comamnd is issued:
------------------------------------------------------------------------
    <1>        <2>                                                 <3>       <4>
$ vol.py --profile Win7SP0x64 --filename win7_trial_64bit.raw pslist --proc_reg DumpIt
  Offset (V)   Name                    PID   PPID   Thds     Hnds   Sess  Wow64 Start                Exit
-------------- -------------------- ------ ------ ------ -------- ------ ------ -------------------- --------------------
0xfa8001016060 DumpIt.exe             2860   1652      2       42      1   True 2012-02-22 11:28:59  -
------------------------------------------------------------------------

<1> The volatility program name (vol.py).

<2> These are global options which are processed by the main volatility
executable (in this case --profile, --filename).

<3> The name of the command plugin to run. This will actually run the first
class to extend plugin.Command() which is also active (in this case
pslist. Since the profile is a windows profile, the WinPSList class will be
invoked).

<4> These options are specific to the plugin - i.e. they have been defined in
the args() classmethod (in this case the process name regex selector).


Volatility is strict with the order in which commands are supplied. For example
it is not valid to provide the --proc_reg parameter before the pslist keyword
(since it is a module level parameter). Similarly it is not legal to provide the
--filename parameter after the command name (pslist). This strictness allows
different modules to define the same command line option for their own needs and
avoids any command line option clashes between different plugins.

This strictness can easily be observed when requesting help. Without a module
name, the help output simply lists those options processed by the main program
(i.e. global options). It also provides a list of available modules:

------------------------------------------------------------------------
$ vol.py --help
usage: vol.py [-h] [--pager PAGER]
              [--logging {debug,info,warning,critical,error}] [--debug]
              [-p PROFILE] [-f FILENAME] [--renderer RENDERER]
              [--plugin PLUGIN [PLUGIN ...]] [--output OUTPUT] [--overwrite]
              Plugin ...

optional arguments:
  -h, --help            show this help message and exit
  --pager PAGER         The pager to use when output is larger than a screen
                        full.
  --logging {debug,info,warning,critical,error}
                        Logging level to show messages.
  --debug               If set we break into the debugger on error conditions.
  -p PROFILE, --profile PROFILE
                        Name of the profile to load.
  -f FILENAME, --filename FILENAME
                        The raw image to load.
  --renderer RENDERER   The renderer to use. e.g. (TextRenderer,
                        JsonRenderer).
  --plugin PLUGIN [PLUGIN ...]
                        Load user provided plugin bundle.
  --output OUTPUT       Write to this output file.
  --overwrite           Allow overwriting of output files.

subcommands:
  The following plugins can be selected.

  Plugin
    modscan             Scan Physical memory for _LDR_DATA_TABLE_ENTRY
                        objects.
    driverscan          Scan for driver objects _DRIVER_OBJECT
    memmap              Calculates the memory regions mapped by a process.
    load_as             Load address spaces into the session if its not
                        already loaded.
------------------------------------------------------------------------

Once the module is provided, we see a per-module help output:
------------------------------------------------------------------------
$ vol.py pslist --help
usage: vol.py pslist [-h] [--kdbg KDBG] [--eprocess EPROCESS [EPROCESS ...]]
                     [--phys_eprocess PHYS_EPROCESS [PHYS_EPROCESS ...]]
                     [--pid PID [PID ...]] [--proc_regex PROC_REGEX]

List processes for windows.

optional arguments:
  -h, --help            show this help message and exit
  --kdbg KDBG           Location of the KDBG structure.
  --eprocess EPROCESS [EPROCESS ...]
                        Kernel addresses of eprocess structs.
  --phys_eprocess PHYS_EPROCESS [PHYS_EPROCESS ...]
                        Physical addresses of eprocess structs.
  --pid PID [PID ...]   One or more pids of processes to select.
  --proc_regex PROC_REGEX
                        A regex to select a profile by name.
------------------------------------------------------------------------


Interactive Session Invocation.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When invoked without a command name, Volatility drops into the interactive
shell. This mode of operation is more efficient as many commands can be run
without needing to reinitialize the framework each time.

This is what happens during initialization:
------------------------------------------------------------------------
$ vol.py --profile Win7SP0x64 --filename win7_trial_64bit.raw
Python 2.6.5 (r265:79063, Apr 16 2010, 13:57:41)
Type "copyright", "credits" or "license" for more information.

The Volatility Memory Forensic Framework technology preview (3.0_tp2).

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License.

Win7SP0x64:win7_trial_64bit.raw 01:32:55> print session               <1>
Volatility session Started on Sun Sep 23 01:32:57 2012.

Config:
 base_filename:  'win7_trial_64bit.raw'
 filename:  'win7_trial_64bit.raw'                                    <2>
 logging:  'INFO'
 overwrite:  False
 pager:  <Set this to your favourite pager.>
 paging_limit:  50
...

Win7SP0x64:win7_trial_64bit.raw 01:33:07> plugins.[tab][tab]          <3>
plugins.atoms           plugins.dlldump         plugins.handles
plugins.atomscan        plugins.dlllist         plugins.hivedump
plugins.callbacks       plugins.driverirp       plugins.hivescan
plugins.clipboard       plugins.driverscan      plugins.imagecopy
....

Win7SP0x64:win7_trial_64bit.raw 01:34:57> pslist proc_regex="DumpIt"  <4>
----------------------------------------> pslist(proc_regex="DumpIt")
  Offset (V)   Name                    PID   PPID   Thds     Hnds   Sess  Wow64 Start                Exit
-------------- -------------------- ------ ------ ------ -------- ------ ------ -------------------- --------------------
0xfa8001016060 DumpIt.exe             2860   1652      2       42      1   True 2012-02-22 11:28:59  -

------------------------------------------------------------------------

<1> A new session.Session() object is created. This holds all information about
the current running session.

<2> Global command line args are parsed into the session - so for example, the
--filename argument is parsed into session.filename.

<3> The is_active() method for all command plugins is called, and the names of
all active plugins are collected. For example, if we have a windows based
profile, WinPSList will return True for is_active() and will be considered
active.

<4> For all active commands, we create wrapper functions in the session object
and the namespace of the interactive shell. The wrapper will automatically set
up a TextRenderer, instantiate the plugin and call its render method with the
text renderer. For example, when the user types pslist() in the interactive UI,
we create a new TextRenderer, instantiate the WinPSList class and call its
render method.



[[as]]
Address Spaces.
---------------

Volatility uses an address space to abstract the handling of different images
and formats and therefore allow plugins to support multiple kind of input images
(or indeed live memory) easiy.

An 'address space' is an object which can satisfy a read request for data at a
certain offset. Exactly how this read request is satisfied is not important to
the rest of the code, so long as the read request is satisfied.

There are a number of simple address spaces which simply provide access to a
specific data source:

1. FileAddressSpace - Simply opens a file and satisfies read requests from it.
2. WindowsHiberFileSpace - Supports windows hibernation files.

However, many other address spaces satisfy their read requests by translating
these to an underlying 'base' address space which does the actual reading. This
is called 'Address Space Stacking' since address spaces are stacked over one
another.

For example, the WindowsCrashDumpSpace32 address space usually stacks over a
FileAddressSpace - which does the actual reading. All the
WindowsCrashDumpSpace32 does it translate the read request from a the provided
offset to another read request at a different offset. Commonly address space
stacking occurs when volatility emulates the hardware page translation by
creating a 'Virtual Address Space' with the IA32PagedMemory and Amd64 paged
address spaces stacked over the 'Physical Address Space'.

.A sample address space stacking.
image::images/address_space.jpg[align="center"]

The figure above shows an IA32PagedMemory Virtual address space stacked over a
FileAddressSpace physical address space. A read request to the virtual address
space get translated through the page tables into a read in the physical memory
address space. The other interesting point is that the Virtual Address space is
sparse - i.e. there are regions where a read request is meaningless because
there is no valid mapping. This happens in the IA32PagedMemory address space
whenever there is no corresponding page translation.

New address spaces, should extend the BaseAddressSpace class and implement at
least:

`__init__(base, **kwargs)`::
 You will receive the address space you need to stack over. The constructor is
 supposed to implement the required sanity checks. If it is not possible to
 stack over the base address for some reason, you must raise an
 ASAssertionError(). Its best to use self.as_assert() to test for various
 conditions.

`read(address, length)`::
 This function should return a buffer read at the specified address. If the
 address is invalid it should return None. Note that in general memory forensics
 should expect a read to fail since any page can be invalid at any
 time. Therefore use of this function is discouraged in favour of the zread()
 function below. This function will probably be deprecated in future.

`zread(address, length)`::
 This variant is almost always called.  If the address is invalid, returns a
 null padded buffer instead.

`vtop(address)`::
 This function returns the physical translation for the virtual address. I.e. it
 returns the offset that this AS will be reading into its base. If the address
 is invalid returns None. This is a quick way to check if a certain address is
 valid.

`get_address_ranges()`::
 Many address spaces are sparse and quite large (e.g. AMD64PagedMemory). When
 scanning these address spaces we need to know which regions are valid so we can
 skip unmapped regions. This function basically returns a list of ranges which
 are valid.


Many image file formats implement essentially a sparse file (i.e. the image
consists of sections which are stored back to back but which refer to sparse
memory regions.). To make it easier to support these there is a generic
RunBasedAddressSpace. Extending this class and populating the self.runs array
with the mappings from virtual space to physical space is all that is required
to support these image file formats. Currents the address spaces which are
supported in this way are WindowsCrashDumpSpace, Elf64CoreDump (for virtual
box), MACHOCoreDump (for osx).


Automatic Address Space Selection
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Most volatility plugins expect to have valid address spaces set in the session
object before they run. There are two main session parameters which are commonly
required, the 'session.physical_address_space' and
'session.kernel_address_space'. Usually if these parameters are not provided in
the session, the plugins will automatically invoke the 'load_as()' plugin.


The load_as plugin is just a regular command plugin, which means that it can be
implemented by different plugin.Command() classes (autoselected via the
is_active() class method - see <<commands,Command Plugin>>). This means we can
have one implementation for windows, one for linux etc. The following discusses
the windows implementation since that is much more complex.

The physical address space is derived by an automatic voting algorithm:

1. Start with the None address space and pass it to all address spaces in their
requested order (classes are sorted by their 'order' attribute). Address spaces
which are incompatible with the base address space will raise ASAssertionError
and will be skipped.

2. The first address space which instantiates successfully, will be accepted as
the next base address space.

3. The process is repeated until all address spaces failed to instantiate. We then return the last successfully instantiated address space.

In the windows load_as() plugin, the virtual address space is created from the
kernel's Directory Table Base (DTB). This is usually obtained by scanning the
image for the Idle process - implemented by the find_dtb() command
plugin. Therefore load_as automatically calls the find_dtb() plugin. In other
implementations, the kernel DTB is calculated using some other way (e.g. from
debug symbols).


The object parsing system.
--------------------------

Computers use volatility memory in order to organize data and for program
control. Memory analysis is ultimately all about trying to make sense of a
memory image, and deducing higher level constructs from these.

For example, if a C program defines the following struct:
------------------------------------------------------------------------
typedef unsigned char uchar;
enum {
  OPT1,
  OPT2
} options;

struct foobar {
    enum options flags;
    short int bar;
    uchar *foo;
}
------------------------------------------------------------------------

What should the memory layout be? The answer is not so simple - it depends on
many things such as the compiler used, architecture etc. For example, the
compiler might enforce an alignment on the struct members by inserting padding
between elements.

In practice it is impossible to predict from source code alone what the memory
layout should be. We therefore need the compiler itself to inform us about how
its planning to layout the memory in practice. This information is available
through debug symbol.

[NOTE]
================================================================================
Volatility is in many ways emulating a native debugger. Just like a debugger,
volatility is making sense from the memory image, using debugging symbols.
================================================================================

There are basically two types of debugging systems - the Microsoft PDB system
and the DWARF standard.

DWARF::
  This standard is used mostly on unix like operating systems (and OSX). It
  consists of a DWARF section attached to the binary object (e.g. ELF file) with
  a specially encoded stream providing information about symbols, structures and
  offsets. In order to obtain debugging information, the binary must be rebuilt
  with the appropriate flags.

Microsoft PDB::
 This standard keeps debugging information outside the final binary. The pdb
 file contains the debugging information, and is stored on a server (may be
 private or public). The advantage of this system is that debugging symbols may
 be obtained for release binaries as well (i.e. you do not need to build with
 debugging turned on before hand).


Another important concept to understand is that of a 'Compilation Unit'. A
compilation unit is a self consistent unit of compiled code which uses the same
memory layout for structs. For example a DLL or an object file is a compilation
unit. It is important to note that the same struct may be defined with the same
name but different layout in different compilation units without any problem.


The VTypes language.
~~~~~~~~~~~~~~~~~~~~

Some symbols may not have debugging information, and so we need to write their
definition by hand (say from reverse engineering the symbol). The VTypes
language was developed as an intuitive way to write human readable structure
definitions.

The VTypes language was designed to allow:

- Partial definition of struct members - not all members in the struct must be
  defined. The offset of the member in the struct is explicitly given.

- Struct members are simply names of special classes (inherited from
  obj.BaseObject). These classes take care of actually parsing the data. This
  allows us to interpret the memory offset in arbitrary ways.  These classes are
  instantiated at the required offset.

The following is an example of a vtype definition:
------------------------------------------------------------------------
  '_EPROCESS' : [ 0x270, {                                          <1>
    'Pcb' : [ 0x0, ['_KPROCESS']],                                  <2>
    'ProcessLock' : [ 0x80, ['_EX_PUSH_LOCK']],
    'CreateTime' : [ 0x88, ['_LARGE_INTEGER']],
    'ExitTime' : [ 0x90, ['_LARGE_INTEGER']],
    'RundownProtect' : [ 0x98, ['_EX_RUNDOWN_REF']],
    'UniqueProcessId' : [ 0x9c, ['Pointer', dict(target="Void")]],  <3>
    'ActiveProcessLinks' : [ 0xa0, ['_LIST_ENTRY']],
    'QuotaUsage' : [ 0xa8, ['Array', dict(                          <4>
                   target='unsigned long',
                   count=3
                   )]],
    'QuotaPeak' : [ 0xb4, ['Array',  dict(
                   target='unsigned long',
                   count=3
                   )]],
    'CommitCharge' : [ 0xc0, ['unsigned long']],
    'PeakVirtualSize' : [ 0xc4, ['unsigned long']],
    'VirtualSize' : [ 0xc8, ['unsigned long']],
    'SessionProcessLinks' : [ 0xcc, ['_LIST_ENTRY']],
------------------------------------------------------------------------

<1> This defines the '_EPROCESS' struct as having a size of 0x270 bytes.

<2> The 'Pcb' member of this struct is found at offset 0 and it is of type
'_KPROCESS'.

<3> The 'UniqueProcessId' member is a pointer to void and is found at offset 0x9c.

<4> The 'QuotaUsage' member is an array which will be instantiated at offset
0xa8 from the start of the _EPROCESS struct. The array will have 3 members each
of type 'unsigned long'.

[TIP]
================================================================================
To generate a vtypes file for an executable, simple use the pdbparse project to
fetch the pdb for the binary and convert it to vtypes:
------------------------------------------------------------------------
pdbparse/trunk$ python examples/symchk.py ntoskrnl.exe
Trying http://msdl.microsoft.com/download/symbols/ntkrnlmp.pdb/7A6629B2016A41D3A5D3E7129430544D2/ntkrnlmp.pd_
Connected. Downloading data...
0% 5% 10% 15% 20% 25% 30% 35% 40% 45% 50% 55% 60% 65% 70% 75% 80% 85% 90% 95% 100%
Saved symbols to ntkrnlmp.pd_
Extracting cabinet: ntkrnlmp.pd_
  extracting ntkrnlmp.pdb

All done, no errors.
pdbparse/trunk$ python examples/tpi_vtypes.py ntkrnlmp.pdb > ntkrnlmp.py
pdbparse/trunk$ head ntkrnlmp.py
ntkrnlmp_types = {
  'LIST_ENTRY64' : [ 0x10, {
    'Flink' : [ 0x0, ['unsigned long long']],
    'Blink' : [ 0x8, ['unsigned long long']],
} ],
  'LIST_ENTRY32' : [ 0x8, {
    'Flink' : [ 0x0, ['unsigned long']],
    'Blink' : [ 0x4, ['unsigned long']],
} ],
  '_KUSER_SHARED_DATA' : [ 0x5f0, {
------------------------------------------------------------------------

================================================================================

Usually vtypes are automatically generated from debug information, such as PDB
files or DWARF file. It is not enough to specify this information in practice
however, since PDB files may be incomplete, or just incorrect.

Volatility allows vtypes to be overlayed. This means that some fields in
autogenerated definitions can be overridden by user defined 'overlays'. For
example consider the vtype definition generated from debugging symbols:
------------------------------------------------------------------------
'_EPROCESS' : [ 0x4d0, {
    'Pcb' : [ 0x0, ['_KPROCESS']],
    'ProcessLock' : [ 0x160, ['_EX_PUSH_LOCK']],
    'CreateTime' : [ 0x168, '_LARGE_INTEGER']],
    'ExitTime' : [ 0x170, ['_LARGE_INTEGER']],
    .....
}],
------------------------------------------------------------------------

Although technically CreateTime is stored as a _LARGE_INTEGER, semantically it
is interpreted as a timestamp. We therefore apply the following overlay:
------------------------------------------------------------------------
'_EPROCESS' : [ None, {
    'CreateTime' : [ None, ['WinTimeStamp', {}]]],
    'ExitTime' : [ None, ['WinTimeStamp', {}]],
    .....
}],
------------------------------------------------------------------------

Note how the overlay does not actually specify the struct offset of the fields -
these are still obtained from the debugging symbols. We only specify the
semantic meaning of these fields - information which is not captured in the
debugging symbols.

The WinTimeStamp object is a class which extends the basic BaseObject to provide
special methods to handle the value as a timestamp.

The Volatility object parsing system is the workhorse under the entire
volatility system. It is used to build semantic information from the underlying
memory data by combining debug symbols (for offsets) with user provided semantic
meaning (using overlays and high level classes).

The Profile.
~~~~~~~~~~~~

A profile is an object which unifies semantic information about a particular
compilation unit. The profile is built by applying all relevant overlays and
classes to parse the compilation unit it cares about. For example the following
is a base profile for parsing the Windows kernel:

------------------------------------------------------------------------
class BaseWindowsProfile(basic.BasicWindowsClasses):
    """Common symbols for all of windows kernel profiles."""
    _md_os = "windows"

    def __init__(self, **kwargs):
        super(BaseWindowsProfile, self).__init__(**kwargs)

        self.add_classes({
            '_UNICODE_STRING': _UNICODE_STRING,
            '_EPROCESS': _EPROCESS,
            '_MMVAD_FLAGS2': _MMVAD_FLAGS2,
            '_MMSECTION_FLAGS': _MMSECTION_FLAGS,
            })

        self.add_overlay(windows_overlay)

        # Pooltags for common objects.
        self.add_constants(DRIVER_POOLTAG="Dri\xf6",
                           EPROCESS_POOLTAG="Pro\xe3",
                           THREAD_POOLTAG='\x54\x68\x72\xe5',
                           )
------------------------------------------------------------------------

We can see this profile is applying classes, overlays and constants to the
profile. Viewed as a whole, the profile can be said to implement a parsing
system for the windows kernel.  When a user select the profile with the
--profile command line arg, they are really selecting which profile should be
created for parsing the kernel.


Profile Modifications
~~~~~~~~~~~~~~~~~~~~~

The profile is a self contained system for parsing the kernel data
structures. However, some modules would like to alter the profile slightly - for
example to add new classes replacing the default classes (with additional
methods), or maybe adding new information obtained by reverse engineering
certain data structures. In these cases we wish to 'modify' the profile
definition by adding an improved class definition system.

It is normally discouraged to directly add new BaseObject class implementations
to the volatility framework since the changes will appear in all users of the
profile - potentially clashing with others' modifications. In other words we
want to modify the profile only for the users of this profile.

This can be done by explicitly calling the ProfileModification class in your
plugin. This will install the updated implementation in your profile - without
affecting other profiles. This localized change opens the door for multiple
implementations of profile parsing systems.

For example consider the standard registry parsing implementation in
'volatility.plugins.windows.registry.registry'. This implementation is a fast,
self contained and complete implementation of registry parsing in the windows
kernel. For a plugin to use this implementation, they will need to add it to
their current profile:

------------------------------------------------------------------------
class VolatilityRegisteryImplementation(obj.ProfileModification):
    """The standard volatility registry parsing subsystem."""

    @classmethod
    def modify(cls, profile):                                           <1>
        profile.add_classes(dict(
                _CM_KEY_NODE=_CM_KEY_NODE, _CM_KEY_INDEX=_CM_KEY_INDEX,
                _CM_KEY_VALUE=_CM_KEY_VALUE, _CMHIVE=_CMHIVE
                ))

        profile.add_overlay(registry_overlays)


class RegistryPlugin(common.WindowsCommandPlugin):
    def __init__(self, **kwargs):
        """Operate on in memory registry hives.
        super(RegistryPlugin, self).__init__(**kwargs)

        # Install our specific implementation of registry support.
        self.profile = VolatilityRegisteryImplementation(self.profile)  <2>
------------------------------------------------------------------------

<1> The VolatilityRegisteryImplementation profile modification implements a
complete registry parsing system. It does this by modifying a profile and
replacing certain classes within it with newer classes with additional
functionality.

<2> A plugin wishing to use this new functionality, can upgrade its profile
using the VolatilityRegisteryImplementation modification. Note that the
modification simply produces a new, enhanced profile - the plugin could use the
modified profile interchangeably with the old unmodified profile.  The
modification does not affect other users of the profile.


The Registry parsing implementation.
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This section describes the Volatility registry parsing implementation found in
'volatility.plugins.windows.registry.registry'.

The PE parsing implementation.
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The PE parsing implementation is found in
'volatility.plugins.overlays.windows.pe_vtypes'.


Testing
-------

Previously testing was ad-hoc in the sense that users would run the
plugins they were interested in on their own images, and report any obvious
failures (e.g. an exception or no output at all). However, there was no way to
easily determine if particular plugins stopped working as expected.

The Technology Preview edition of Volatility introduces an automated testing
framework to assist in detecting regressions and bugs when handling different
images. The idea is to automatically compare the output of volatility (or
another tool) between different runs for each plugin. If the output differs, a
regression bug may have been uncovered.

We do this by creating a 'baseline' file which describes the output of one
version of volatility. Ideally the baseline file is the ground truth and can be
independently verified to be correct. We then run the current version of
volatility against the baseline and compare the output in some way.

The baseline itself is created using a template which is generated by the test
case itself. This template can be tweaked for the specific image we have.

The process is therefore:

- Create a test directory and place the image inside it (or a symlink).

- Create a test template for this image. The template specifies information
about executing volatiltiy for each test. For example, command line
parameters. Note that common data is interpolated from the DEFAULT section:

.Sample test configuration file.
------------------------------------------------------------------------
[DEFAULT]
profile = WinXPSP2x86
active = True
filename = xp-laptop-2005-06-25.img

[TestMemmap]
--profile = %(profile)s
commandline = memmap --pid=2624
--filename = %(filename)s
active = True
------------------------------------------------------------------------

-------------------------------------------------------------------
$ python tools/testing/build_suite.py template \                <1>
  --file xp-laptop-2005-06-25_trunk/xp-laptop-2005-06-25.img    <2>
-------------------------------------------------------------------

<1> Run the tool in template mode.
<2> Specify the image the template will use - the template file is placed in the
same directory.


- Build baselines for all the tests specified in this template. It might be
necessary to manually tweak the template here (for example if command line args
have changed between the old and new versions.).

-------------------------------------------------------------------
$ python tools/testing/build_suite.py baseline \                <1>
  --config xp-laptop-2005-06-25_trunk/tests.config \            <2>
  -e "python branches/2.3-devel/vol.py"                         <3>
-------------------------------------------------------------------

<1> Run the tool in baseline mode.
<2> Specify the testing template to use.
<3> Specify the binary to run - in this case we use the 2.3-dev version as a
baseline.


The tool will create a json file for each test in the testing directory. This is
called the baseline data. The baseline contains information about the output
generated:

.Sample baseline image for a test case.
-------------------------------------------------------------------
{
    "time_used": 4.6139168739318848,
    "output": [
        "Offset(V) ||Name                ||   PID||  PPID||  Thds||    Hnds||  Sess|| Wow64||Start               ||Exit                ",
        "----------||--------------------||------||------||------||--------||------||------||--------------------||--------------------",
        "0x823c87c0||System              ||     4||     0||    61||    1140||------||     0||                    ||                    ",
        "0x81fdf020||smss.exe            ||   448||     4||     3||      21||------||     0||2005-06-25 16:47:28 ||                    ",
        "0x81ed84e8||dd.exe              ||  4012||  2624||     1||      22||     0||     0||2005-06-25 16:58:46 ||                    "
    ],
    "options": {
        "--profile": "WinXPSP2x86",
        "commandline": "pslist",
        "--filename": "/tmp/xp-laptop-2005-06-25_trunk/xp-laptop-2005-06-25.img",
        "executable": "python /home/scudette/projects/volatility/trunk/vol.py",
        "mode": "trunk"
    }
}
-------------------------------------------------------------------

- Finally test the current output against the baseline:

-------------------------------------------------------------------
$ python tools/testing/build_suite.py test \                    <1>
  --config xp-laptop-2005-06-25_trunk/tests.config              <2>
-------------------------------------------------------------------

<1> Run the tool in test mode.
<2> Specify the testing template to use.

The test will run and be compared with the baseline. The test will fail if there
was any discrepancy with the baseline.

[NOTE]
================================================================================
The --executable and --mode parameters specify the path to the binary and its
type used for running the test. This is used to compensate for expected
differences in output (by applying regex'es for example). If you are testing the
technology preview against the trunk version you would specify --mode=trunk when
building the baseline, but not when running the test.
================================================================================


