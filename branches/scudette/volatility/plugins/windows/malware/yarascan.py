# Volatility
# Copyright (c) 2012, Michael Cohen <scudette@gmail.com>
# Copyright (c) 2010, 2011, 2012 Michael Ligh <michael.ligh@mnin.org>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or (at
# your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

"""A Volatility scanner which uses yara."""
import sys
import yara

from volatility import constants
from volatility import plugin
from volatility import scan
from volatility import utils
from volatility.plugins.windows import common


class BaseYaraASScanner(scan.BaseScanner):
    """An address space scanner for Yara signatures."""
    overlap = 1024

    def __init__(self, rules=None, **kwargs):
        super(BaseYaraASScanner, self).__init__(**kwargs)
        self.rules = rules

    def scan(self, offset=0, maxlen=None):
        maxlen = maxlen or self.profile.get_constant("MaxPointer")

        # Start scanning from offset until maxlen:
        i = offset

        while i < offset + maxlen:
            # Update the progress bar.
            if self.session:
                self.session.report_progress("Scanning 0x%08X" % i)

            # Read some data and match it.
            to_read = min(constants.SCAN_BLOCKSIZE, maxlen - (i - offset))
            data = self.address_space.read(i, to_read)
            if data:
                for match in self.rules.match(data=data):
                    for offset, name, value in match.strings:
                        if offset < constants.SCAN_BLOCKSIZE - self.overlap:
                            yield match.rule, offset + i, name, value

            i += constants.SCAN_BLOCKSIZE - self.overlap


class DiscontigYaraScanner(scan.DiscontigScanner, BaseYaraASScanner):
    """A discontiguous scanner based on yara signatures."""


class YaraScan(common.WinProcessFilter):
    """Scan using yara signatures."""

    __name = "yarascan"

    @classmethod
    def args(cls, parser):
        super(YaraScan, cls).args(parser)
        parser.add_argument("--string", default=None,
                            help="A verbatim string to search for.")

        parser.add_argument("--yara_file", default=None,
                            help="The yara signature file to read.")

        parser.add_argument("--yara_expression", default=None,
                            help="If provided we scan for this yarra "
                            "expression.")

        parser.add_argument("--scan_vads", default=False, action="store_true",
                            help="If specified we scan the vads of "
                            "processes, else we scan their address spaces.")

    def __init__(self, string=None, address_space=None, scan_vads=False,
                 yara_file=None, yara_expression=None, **kwargs):
        """Scan using yara signatures.

        Args:
          string: A verbatim string to search for.
          address_space: A address space to scan (Default kernel address space).
          scan_vads: If true we scan the vads of the specified processes, else
            we scan their address spaces.
          yara_file: The yara file to read.
          yara_expression: If provided we scan for this yarra expression.
        """
        super(YaraScan, self).__init__(**kwargs)
        if yara_expression:
            self.rules_source = yara_expression
            self.rules = yara.compile(source=self.rules_source)
        elif string:
            self.rules_source = ('rule r1 {strings: $a = "%s" condition: $a}' %
                                 string)
            self.rules = yara.compile(source=self.rules_source)

        elif yara_file:
            self.rules = yara.compile(yara_file)
        else:
            raise plugin.PluginError("You must specify a yara rule file or "
                                     "string to match.")

        self.scan_vads = scan_vads
        self.address_space = address_space

    def generate_hits(self, address_space):
        scanner = DiscontigYaraScanner(
            profile=self.profile, session=self.session,
            address_space=address_space,
            rules=self.rules)

        return scanner.scan()

    def render_kernel_scan(self, renderer):
        modules = self.session.plugins.modules()

        for rule, address, _, hit in self.generate_hits(
            self.kernel_address_space):
            renderer.format("Rule: {0}\n", rule)

            # Find out who owns this hit.
            owner = modules.find_module(address)
            if owner:
                renderer.format("Owner: {0}\n", owner.BaseDllName)
                filename = "kernel.{0:#x}.{1:#x}.dmp".format(
                    owner.obj_offset, address)
            else:
                filename = "kernel.{0:#x}.dmp".format(
                    address)

                renderer.format("Owner: (Unknown Kernel Memory)\n")

            context = self.kernel_address_space.zread(address, 0x40)
            utils.WriteHexdump(renderer, context, base=address)

    def render(self, renderer):
        """Render output."""
        # We are searching the kernel address space
        if self.address_space is None:
            return self.render_kernel_scan(renderer)
