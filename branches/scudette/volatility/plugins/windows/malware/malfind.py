# Volatility
# Copyright (c) 2010, 2011, 2012 Michael Ligh <michael.ligh@mnin.org>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or (at
# your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#


from volatility import obj
from volatility import scan
from volatility.plugins.windows.malware import devicetree
from volatility.plugins.windows import common
from volatility.plugins.overlays.windows import windows
from volatility.plugins.overlays.windows import pe_vtypes

try:
    import yara
    has_yara = True
except ImportError:
    has_yara = False

try:
    import distorm3
    has_distorm3 = True
except ImportError:
    has_distorm3 = False

#--------------------------------------------------------------------------------
# object classes
#--------------------------------------------------------------------------------

class MalwareEPROCESS(windows._EPROCESS):
    """Extension of the default EPROCESS with some helpers"""

    def session_id(self):
        """Returns the Session ID of the process"""

        if self.Session.is_valid():
            process_space = self.get_process_address_space()
            if process_space:
                return obj.Object("_MM_SESSION_SPACE",
                                  offset = self.Session,
                                  vm = process_space).SessionId

        return obj.NoneObject("Cannot find process session")

    def search_process_memory(self, s, filter = None):
        """Search memory for a simple byte string.

        @param s: the string to search for
        @param filter: a callable (can be lambda)
            that applies a fitler to the MMVAD and returns
            True if the vad should be searched, or false
            otherwise. For example, to only search
            private memory segments you can use the following:
            filter=lambda x: x.u.VadFlags.PrivateMemory == 1.
            If filter is not supplied, all vads are searched.
        """

        for vad in self.get_vads():
            if vad == None:
                continue
            if filter:
                if not filter(vad):
                    continue
            # Get the memory contents
            data = vad.get_data()
            # Track our position through the buffer
            offset = 0
            while 1:
                next_offset = data[offset:].find(s)
                if next_offset == -1:
                    break
                address = vad.Start + offset + next_offset
                yield address
                offset += next_offset + len(s)

    def find_injections(self):
        """
        Find injected code.

        This looks for private allocations that are committed,
        memory-resident, non-empty (not all zeros) and with an
        original protection that includes execute rights.

        It is important to note that protections are applied at
        the allocation granularity (page level). Thus the original
        protection might not be the current protection, and it
        also might not apply to all pages in the VAD range.
        """

        for vad in self.get_vads():
            if vad == None:
                continue
            # Memory must be private
            if vad.u.VadFlags.PrivateMemory == 0:
                continue
            protect_str = vadinfo.PROTECT_FLAGS.get(vad.u.VadFlags.Protection.v(), "")
            # Memory must be writable and executable
            if not "EXECUTE" in protect_str or not "WRITE" in protect_str:
                continue
            # The private memory check above will usually ensure
            # we've found a short vad, but not always
            if vad.Tag != "VadS":
                continue
            data = vad.get_data()
            # Skip empty segments
            if data.count(chr(0)) == len(data):
                continue
            yield vad, data

    def list_mapped_files(self, exe_only = True):
        """
        Generator for mapped files in process memory.

        @param exe_only: only find files that appear
            to be executables by checking the first two
            bytes are MZ.
        """

        process_space = self.get_process_address_space()

        for vad in self.get_vads():
            if vad == None:
                continue
            # Move on if there's no _FILE_OBJECT
            try:
                file_obj = vad.FileObject
            except AttributeError:
                continue
            # Move on if the memory isn't executable. This ignores
            # mapped files like fonts and other data files.
            if not exe_only or process_space.zread(vad.Start, 2) == "MZ":
                yield vad, file_obj.FileName

#--------------------------------------------------------------------------------
# profile modifications
#--------------------------------------------------------------------------------

class MalwareObjectClasesXP(obj.ProfileModification):
    before = ['WindowsObjectClasses']
    conditions = {'os': lambda x: x == 'windows',
                  'major': lambda x: x == 5,
                  'minor': lambda x: x <= 2}
    def modification(self, profile):
        profile.object_classes.update({
            '_EPROCESS': MalwareEPROCESS,
        })

class MalwareObjectClases2003(obj.ProfileModification):
    before = ['WindowsObjectClasses', 'Win2003MMVad']

    def check(self, profile):
        m = profile.metadata
        return (m.get('os', None) == 'windows' and
                (m.get('major') > 5 or (m.get('major') == 5 and m.get('minor') >= 2)))

    def modification(self, profile):
        profile.object_classes.update({
           '_EPROCESS': _EPROCESSwin2003,
       })

#--------------------------------------------------------------------------------
# functions
#--------------------------------------------------------------------------------

def Disassemble(data, start, bits = '32bit', stoponret = False):
    """Dissassemble code with distorm3.

    @param data: python byte str to decode
    @param start: address where `data` is found in memory
    @param bits: use 32bit or 64bit decoding
    @param stoponret: stop disasm when function end is reached

    @returns: tuple of (offset, instruction, hex bytes)
    """

    if not has_distorm3:
        raise StopIteration

    if bits == '32bit':
        mode = distorm3.Decode32Bits
    else:
        mode = distorm3.Decode64Bits

    for o, _, i, h in distorm3.DecodeGenerator(start, data, mode):
        if stoponret and i.startswith("RET"):
            raise StopIteration
        yield o, i, h

#--------------------------------------------------------------------------------
# yarascan
#--------------------------------------------------------------------------------

class YaraScan(common.WindowsCommandPlugin):
    "Scan process or kernel memory with Yara signatures"

    def __init__(self, config, *args, **kwargs):
        taskmods.DllList.__init__(self, config, *args, **kwargs)
        config.add_option("KERNEL", short_option='K', default=False, action='store_true',
                        help='Scan kernel modules')
        config.add_option("WIDE", short_option='W', default=False, action='store_true',
                        help='Match wide (unicode) strings')
        config.add_option('YARA-RULES', short_option='Y', default=None,
                        help='Yara rules (as a string)')
        config.add_option('YARA-FILE', short_option='y', default=None,
                        help='Yara rules (rules file)')
        config.add_option('DUMP-DIR', short_option='D', default=None,
                        help='Directory in which to dump the files')

    def calculate(self):

        if not has_yara:
            debug.error("Please install Yara from code.google.com/p/yara-project")

        addr_space = utils.load_as(self._config)

        if self._config.YARA_RULES:
            s = self._config.YARA_RULES
            # Don't wrap hex or regex rules in quotes
            if s[0] not in ("{", "/"): s = '"' + s + '"'
            # Scan for unicode strings
            if self._config.WIDE: s += "wide"
            rules = yara.compile(sources={
                        'n' : 'rule r1 {strings: $a = ' + s + ' condition: $a}'
                        })
        elif self._config.YARA_FILE:
            rules = yara.compile(self._config.YARA_FILE)
        else:
            debug.error("You must specify a string (-Y) or a rules file (-y)")

        if self._config.KERNEL:

            # Find KDBG so we know where kernel memory begins. Do not assume
            # the starting range is 0x80000000 because we may be dealing with
            # an image with the /3GB boot switch.
            kdbg = tasks.get_kdbg(addr_space)
            start = kdbg.MmSystemRangeStart.dereference_as("address")

            ## What's a better way to determine the end?
            if addr_space.profile.metadata.get('memory_model', '32bit') == '32bit':
                stop = 0xFFFFFFFF
            else:
                stop = 0xFFFFFFFFFFFFFFFF

            # Size of chunks to read as we brute force through the AS
            chunksize = 0x100000 # 1 MB

            # Modules so we can map addresses to owners
            mods = dict((mod.DllBase, mod)
                        for mod in modules.lsmod(addr_space))
            mod_addrs = sorted(mods.keys())

            # There are multiple views (GUI sessions) of kernel memory.
            # Since we're scanning virtual memory and not physical,
            # all sessions must be scanned for full coverage. This
            # really only has a positive effect if the data you're
            # searching for is in GUI memory.
            sessions = []

            for proc in tasks.pslist(addr_space):
                sid = proc.session_id()
                # Skip sessions we've already seen
                if sid == None or sid in sessions:
                    continue
                session_space = proc.get_process_address_space()
                if session_space == None:
                    continue
                sessions.append(sid)
                for addr in xrange(0, stop - start, chunksize):
                    data = session_space.zread(start + addr, chunksize)
                    # Skip chunks that are all zero - saves time
                    if data.count(chr(0)) == len(data):
                        continue
                    for hit in rules.match(data = data):
                        for (offset, _, _) in hit.strings:
                            address = start + addr + offset
                            module = tasks.find_module(mods, mod_addrs, address)
                            yield module, address, hit, data[offset:]
        else:
            for task in self.filter_tasks(tasks.pslist(addr_space)):
                for vad in task.get_vads():
                    if vad == None:
                        continue
                    data = vad.get_data()
                    # Skip chunks that are all zero - saves time
                    if data.count(chr(0)) == len(data):
                        continue
                    for hit in rules.match(data = data):
                        for (offset, _, _) in hit.strings:
                            address = vad.Start + offset
                            yield task, address, hit, data[offset:]

    def render_text(self, outfd, data):

        for o, addr, hit, content in data:
            outfd.write("Rule: {0}\n".format(hit.rule))

            # Find out if the hit is from user or kernel mode
            if o == None:
                outfd.write("Owner: (Unknown Kernel Memory)\n")
                filename = "kernel.{0:#x}.dmp".format(addr)
            elif o.obj_name == "_EPROCESS":
                outfd.write("Owner: Process {0} Pid {1}\n".format(o.ImageFileName,
                    o.UniqueProcessId))
                filename = "process.{0:#x}.{1:#x}.dmp".format(o.obj_offset, addr)
            else:
                outfd.write("Owner: {0}\n".format(o.BaseDllName))
                filename = "kernel.{0:#x}.{1:#x}.dmp".format(o.obj_offset, addr)

            # Dump the data if --dump-dir was supplied
            if self._config.DUMP_DIR:
                path = os.path.join(self._config.DUMP_DIR, filename)
                fh = open(path, "wb")
                fh.write(content)
                fh.close()

            outfd.write("".join(
                ["{0:#010x}  {1:<48}  {2}\n".format(addr + o, h, ''.join(c))
                for o, h, c in utils.Hexdump(content[0:64])
                ]))

#--------------------------------------------------------------------------------
# malfind
#--------------------------------------------------------------------------------

class Malfind(common.WindowsCommandPlugin):
    "Find hidden and injected code"

    def render_text(self, outfd, data):
        for task in data:
            for vad, content in task.find_injections():

                outfd.write("Process: {0} Pid: {1} Address: {2:#x}\n".format(
                    task.ImageFileName, task.UniqueProcessId, vad.Start))

                outfd.write("Vad Tag: {0} Protection: {1}\n".format(
                    vad.Tag, vadinfo.PROTECT_FLAGS.get(vad.u.VadFlags.Protection.v(), "")))

                outfd.write("Flags: {0}\n".format(str(vad.u.VadFlags)))
                outfd.write("\n")

                outfd.write("{0}\n".format("\n".join(
                    ["{0:#010x}  {1:<48}  {2}".format(vad.Start, h, ''.join(c))
                    for o, h, c in utils.Hexdump(content[0:64])
                    ])))

                outfd.write("\n")
                outfd.write("\n".join(
                    ["{0:#x} {1:<16} {2}".format(o, h, i)
                    for o, i, h in Disassemble(content[0:64], vad.Start)
                    ]))

                outfd.write("\n\n")

#--------------------------------------------------------------------------------
# ldrmodules
#--------------------------------------------------------------------------------

class LdrModules(common.WinProcessFilter):
    "Detect unlinked DLLs"

    __name = "ldrmodules"

    def __init__(self, verbose=False, **kwargs):
        """Detect unlinked DLLs.

        Args:
          verbose: Print more information about the mapped filenames.
        """
        super(LdrModules, self).__init__(**kwargs)
        self.verbose = verbose or self.session.verbose

    def list_mapped_files(self, task):
        """Iterates over all vads and returns executable regions.

        Yields:
          vad objects which are both executable and have a file name.
        """
        for vad in task.VadRoot.traverse():
            vad = vad.dereference()
            if vad:
                try:
                    file_obj = vad.ControlArea.FilePointer
                    if (file_obj.FileName and
                        "EXECUTE" in str(vad.u.VadFlags.ProtectionEnum)):
                        yield vad, file_obj.FileName
                except AttributeError:
                    pass

    def render(self, renderer):
        for task in self.filter_processes():
            renderer.section()
            renderer.table_header([("Pid", "pid", "8"),
                                   ("Process", "process", "20"),
                                   ("Base", "base_address", "[addrpad]"),
                                   ("InLoad", "in_load", "5"),
                                   ("InInit", "in_init", "5"),
                                   ("InMem", "in_mem", "5"),
                                   ("MappedPath", "mapped_filename", "")
                                   ])

            # Build a dictionary for all three PEB lists where the
            # keys are base address and module objects are the values
            inloadorder = dict((mod.DllBase.v(), mod)
                                for mod in task.get_load_modules())

            ininitorder = dict((mod.DllBase.v(), mod)
                                for mod in task.get_init_modules())

            inmemorder  = dict((mod.DllBase.v(), mod)
                                for mod in task.get_mem_modules())

            # Build a similar dictionary for the mapped files
            mapped_files = dict((vad.Start, name)
                                for vad, name in self.list_mapped_files(task))

            # For each base address with a mapped file, print info on
            # the other PEB lists to spot discrepancies.
            for base in mapped_files.keys():
                # Report if the mapped files are in the PEB lists
                renderer.table_row(task.UniqueProcessId,
                                   task.ImageFileName,
                                   base,
                                   base in inloadorder,
                                   base in ininitorder,
                                   base in inmemorder,
                                   mapped_files[base])

                # Print the full paths and base names in verbose mode
                if self.verbose:
                    for mod_list, name in ([inloadorder, "Load"],
                                           [ininitorder, "Init"],
                                           [inmemorder, "Mem"]):
                        if base in mod_list:
                            load_mod = mod_list[base]
                            renderer.format("  {0} Path: {1} : {2}\n",
                                            name, load_mod.FullDllName,
                                            load_mod.BaseDllName)



