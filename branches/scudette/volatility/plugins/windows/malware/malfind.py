# Volatility
# Copyright (c) 2010, 2011, 2012 Michael Ligh <michael.ligh@mnin.org>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or (at
# your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#


from volatility import obj
from volatility import scan
from volatility import utils
from volatility.plugins.windows.malware import devicetree
from volatility.plugins.windows import common
from volatility.plugins.overlays.windows import windows
from volatility.plugins.overlays.windows import pe_vtypes

try:
    import yara
    has_yara = True
except ImportError:
    has_yara = False

try:
    import distorm3
    has_distorm3 = True
except ImportError:
    has_distorm3 = False

#--------------------------------------------------------------------------------
# object classes
#--------------------------------------------------------------------------------

class MalwareEPROCESS(windows._EPROCESS):
    """Extension of the default EPROCESS with some helpers"""

    def session_id(self):
        """Returns the Session ID of the process"""

        if self.Session.is_valid():
            process_space = self.get_process_address_space()
            if process_space:
                return obj.Object("_MM_SESSION_SPACE",
                                  offset = self.Session,
                                  vm = process_space).SessionId

        return obj.NoneObject("Cannot find process session")

    def search_process_memory(self, s, filter = None):
        """Search memory for a simple byte string.

        @param s: the string to search for
        @param filter: a callable (can be lambda)
            that applies a fitler to the MMVAD and returns
            True if the vad should be searched, or false
            otherwise. For example, to only search
            private memory segments you can use the following:
            filter=lambda x: x.u.VadFlags.PrivateMemory == 1.
            If filter is not supplied, all vads are searched.
        """

        for vad in self.get_vads():
            if vad == None:
                continue
            if filter:
                if not filter(vad):
                    continue
            # Get the memory contents
            data = vad.get_data()
            # Track our position through the buffer
            offset = 0
            while 1:
                next_offset = data[offset:].find(s)
                if next_offset == -1:
                    break
                address = vad.Start + offset + next_offset
                yield address
                offset += next_offset + len(s)

    def find_injections(self):
        """
        Find injected code.

        This looks for private allocations that are committed,
        memory-resident, non-empty (not all zeros) and with an
        original protection that includes execute rights.

        It is important to note that protections are applied at
        the allocation granularity (page level). Thus the original
        protection might not be the current protection, and it
        also might not apply to all pages in the VAD range.
        """

        for vad in self.get_vads():
            if vad == None:
                continue
            # Memory must be private
            if vad.u.VadFlags.PrivateMemory == 0:
                continue
            protect_str = vadinfo.PROTECT_FLAGS.get(vad.u.VadFlags.Protection.v(), "")
            # Memory must be writable and executable
            if not "EXECUTE" in protect_str or not "WRITE" in protect_str:
                continue
            # The private memory check above will usually ensure
            # we've found a short vad, but not always
            if vad.Tag != "VadS":
                continue
            data = vad.get_data()
            # Skip empty segments
            if data.count(chr(0)) == len(data):
                continue
            yield vad, data

    def list_mapped_files(self, exe_only = True):
        """
        Generator for mapped files in process memory.

        @param exe_only: only find files that appear
            to be executables by checking the first two
            bytes are MZ.
        """

        process_space = self.get_process_address_space()

        for vad in self.get_vads():
            if vad == None:
                continue
            # Move on if there's no _FILE_OBJECT
            try:
                file_obj = vad.FileObject
            except AttributeError:
                continue
            # Move on if the memory isn't executable. This ignores
            # mapped files like fonts and other data files.
            if not exe_only or process_space.zread(vad.Start, 2) == "MZ":
                yield vad, file_obj.FileName

#--------------------------------------------------------------------------------
# profile modifications
#--------------------------------------------------------------------------------

class MalwareObjectClasesXP(obj.ProfileModification):
    before = ['WindowsObjectClasses']
    conditions = {'os': lambda x: x == 'windows',
                  'major': lambda x: x == 5,
                  'minor': lambda x: x <= 2}
    def modification(self, profile):
        profile.object_classes.update({
            '_EPROCESS': MalwareEPROCESS,
        })

class MalwareObjectClases2003(obj.ProfileModification):
    before = ['WindowsObjectClasses', 'Win2003MMVad']

    def check(self, profile):
        m = profile.metadata
        return (m.get('os', None) == 'windows' and
                (m.get('major') > 5 or (m.get('major') == 5 and m.get('minor') >= 2)))

    def modification(self, profile):
        profile.object_classes.update({
           '_EPROCESS': _EPROCESSwin2003,
       })

#--------------------------------------------------------------------------------
# functions
#--------------------------------------------------------------------------------

def Disassemble(data, start, bits = '32bit', stoponret = False):
    """Dissassemble code with distorm3.

    @param data: python byte str to decode
    @param start: address where `data` is found in memory
    @param bits: use 32bit or 64bit decoding
    @param stoponret: stop disasm when function end is reached

    @returns: tuple of (offset, instruction, hex bytes)
    """

    if not has_distorm3:
        raise StopIteration

    if bits == '32bit':
        mode = distorm3.Decode32Bits
    else:
        mode = distorm3.Decode64Bits

    for o, _, i, h in distorm3.DecodeGenerator(start, data, mode):
        if stoponret and i.startswith("RET"):
            raise StopIteration
        yield o, i, h


#--------------------------------------------------------------------------------
# malfind
#--------------------------------------------------------------------------------
class Malfind(common.WinProcessFilter):
    "Find hidden and injected code"

    __name = "malfind"

    def _is_vad_empty(self, vad, address_space):
        """
        Check if a VAD region is either entirely unavailable
        due to paging, entirely consiting of zeros, or a
        combination of the two. This helps ignore false positives
        whose VAD flags match task._injection_filter requirements
        but there's no data and thus not worth reporting it.

        @param vad: an MMVAD object in kernel AS
        @param address_space: the process address space
        """

        PAGE_SIZE = 0x1000
        all_zero_page = "\x00" * PAGE_SIZE

        offset = 0
        while offset < vad.Length:
            next_addr = vad.Start + offset
            if (address_space.is_valid_address(next_addr) and
                    address_space.read(next_addr, PAGE_SIZE) != all_zero_page):
                return False
            offset += PAGE_SIZE

        return True

    def _injection_filter(self, vad, task_as):
        """Detects injected vad regions.

        This looks for private allocations that are committed,
        memory-resident, non-empty (not all zeros) and with an
        original protection that includes write and execute.

        It is important to note that protections are applied at
        the allocation granularity (page level). Thus the original
        protection might not be the current protection, and it
        also might not apply to all pages in the VAD range.

        @param vad: an MMVAD object.

        @returns: True if the MMVAD looks like it might
        contain injected code.
        """
        if self._is_vad_empty(vad, task_as):
            return False

        # Try to find injections.
        protect = str(vad.u.VadFlags.ProtectionEnum)
        write_exec = "EXECUTE" in protect and "WRITE" in protect

        # The Write/Execute check applies to everything
        if not write_exec:
            return False

        # This is a typical VirtualAlloc'd injection
        if vad.u.VadFlags.PrivateMemory == 1 and vad.Tag == "VadS":
            return True

        # This is a stuxnet-style injection
        if (vad.u.VadFlags.PrivateMemory == 0 and
            protect != "EXECUTE_WRITECOPY"):
            return True

        return False

    def render(self, renderer):
        for task in self.filter_processes():
            task_as = task.get_process_address_space()
            if not task_as:
                continue

            for vad in task.RealVadRoot.traverse():
                if self._injection_filter(vad, task_as):
                    renderer.section()
                    renderer.format("Process: {0} Pid: {1} Address: {2:#x}\n",
                                    task.ImageFileName, task.UniqueProcessId,
                                    vad.Start)

                    renderer.format("Vad Tag: {0} Protection: {1}\n",
                                    vad.Tag, vad.u.VadFlags.ProtectionEnum)

                    renderer.format("Flags: {0}\n", vad.u.VadFlags)
                    renderer.format("\n")

                    dumper = self.session.plugins.dump(
                        target=task_as, suppress_headers=True,
                        offset=vad.Start, rows=5)
                    dumper.render(renderer)

                    renderer.format("\n")
                    disassembler = self.session.plugins.dis(
                        address_space=task_as, suppress_headers=True,
                        offset=vad.Start)
                    disassembler.render(renderer)

#--------------------------------------------------------------------------------
# ldrmodules
#--------------------------------------------------------------------------------

class LdrModules(common.WinProcessFilter):
    "Detect unlinked DLLs"

    __name = "ldrmodules"

    def __init__(self, verbose=False, **kwargs):
        """Detect unlinked DLLs.

        Args:
          verbose: Print more information about the mapped filenames.
        """
        super(LdrModules, self).__init__(**kwargs)
        self.verbose = verbose or self.session.verbose

    def list_mapped_files(self, task):
        """Iterates over all vads and returns executable regions.

        Yields:
          vad objects which are both executable and have a file name.
        """
        task_as = task.get_process_address_space()
        for vad in task.RealVadRoot.traverse():
            if vad:
                try:
                    file_obj = vad.ControlArea.FilePointer
                    if ("EXECUTE" in str(vad.u.VadFlags.ProtectionEnum) and
                        task_as.zread(vad.Start, 2) == "MZ"):
                        yield vad, file_obj.FileName
                except AttributeError:
                    pass

    def render(self, renderer):
        renderer.table_header([("Pid", "pid", "8"),
                               ("Process", "process", "20"),
                               ("Base", "base_address", "[addrpad]"),
                               ("InLoad", "in_load", "5"),
                               ("InInit", "in_init", "5"),
                               ("InMem", "in_mem", "5"),
                               ("MappedPath", "mapped_filename", "")
                               ])

        for task in self.filter_processes():
            # Build a dictionary for all three PEB lists where the
            # keys are base address and module objects are the values
            inloadorder = dict((mod.DllBase.v(), mod)
                                for mod in task.get_load_modules())

            ininitorder = dict((mod.DllBase.v(), mod)
                                for mod in task.get_init_modules())

            inmemorder  = dict((mod.DllBase.v(), mod)
                                for mod in task.get_mem_modules())

            # Build a similar dictionary for the mapped files
            mapped_files = dict((vad.Start, name)
                                for vad, name in self.list_mapped_files(task))

            # For each base address with a mapped file, print info on
            # the other PEB lists to spot discrepancies.
            for base in mapped_files.keys():
                # Report if the mapped files are in the PEB lists
                renderer.table_row(task.UniqueProcessId,
                                   task.ImageFileName,
                                   base,
                                   base in inloadorder,
                                   base in ininitorder,
                                   base in inmemorder,
                                   mapped_files[base])

                # Print the full paths and base names in verbose mode
                if self.verbose:
                    for mod_list, name in ([inloadorder, "Load"],
                                           [ininitorder, "Init"],
                                           [inmemorder, "Mem"]):
                        if base in mod_list:
                            load_mod = mod_list[base]
                            renderer.format("  {0} Path: {1} : {2}\n",
                                            name, load_mod.FullDllName,
                                            load_mod.BaseDllName)
