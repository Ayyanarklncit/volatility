# Volatility
# Copyright (c) 2010, 2011, 2012 Michael Ligh <michael.ligh@mnin.org>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or (at
# your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#
import re

from volatility import obj
from volatility import utils
from volatility.plugins.windows import filescan

#--------------------------------------------------------------------------------
# constants
#--------------------------------------------------------------------------------
overlay = {
    '_DEVICE_OBJECT': [None, {
            'DeviceType': [None, ['Enumeration', dict(choices={
                            0x00000027 : 'FILE_DEVICE_8042_PORT',
                            0x00000032 : 'FILE_DEVICE_ACPI',
                            0x00000029 : 'FILE_DEVICE_BATTERY',
                            0x00000001 : 'FILE_DEVICE_BEEP',
                            0x0000002a : 'FILE_DEVICE_BUS_EXTENDER',
                            0x00000002 : 'FILE_DEVICE_CD_ROM',
                            0x00000003 : 'FILE_DEVICE_CD_ROM_FILE_SYSTEM',
                            0x00000030 : 'FILE_DEVICE_CHANGER',
                            0x00000004 : 'FILE_DEVICE_CONTROLLER',
                            0x00000005 : 'FILE_DEVICE_DATALINK',
                            0x00000006 : 'FILE_DEVICE_DFS',
                            0x00000035 : 'FILE_DEVICE_DFS_FILE_SYSTEM',
                            0x00000036 : 'FILE_DEVICE_DFS_VOLUME',
                            0x00000007 : 'FILE_DEVICE_DISK',
                            0x00000008 : 'FILE_DEVICE_DISK_FILE_SYSTEM',
                            0x00000033 : 'FILE_DEVICE_DVD',
                            0x00000009 : 'FILE_DEVICE_FILE_SYSTEM',
                            0x0000003a : 'FILE_DEVICE_FIPS',
                            0x00000034 : 'FILE_DEVICE_FULLSCREEN_VIDEO',
                            0x0000000a : 'FILE_DEVICE_INPORT_PORT',
                            0x0000000b : 'FILE_DEVICE_KEYBOARD',
                            0x0000002f : 'FILE_DEVICE_KS',
                            0x00000039 : 'FILE_DEVICE_KSEC',
                            0x0000000c : 'FILE_DEVICE_MAILSLOT',
                            0x0000002d : 'FILE_DEVICE_MASS_STORAGE',
                            0x0000000d : 'FILE_DEVICE_MIDI_IN',
                            0x0000000e : 'FILE_DEVICE_MIDI_OUT',
                            0x0000002b : 'FILE_DEVICE_MODEM',
                            0x0000000f : 'FILE_DEVICE_MOUSE',
                            0x00000010 : 'FILE_DEVICE_MULTI_UNC_PROVIDER',
                            0x00000011 : 'FILE_DEVICE_NAMED_PIPE',
                            0x00000012 : 'FILE_DEVICE_NETWORK',
                            0x00000013 : 'FILE_DEVICE_NETWORK_BROWSER',
                            0x00000014 : 'FILE_DEVICE_NETWORK_FILE_SYSTEM',
                            0x00000028 : 'FILE_DEVICE_NETWORK_REDIRECTOR',
                            0x00000015 : 'FILE_DEVICE_NULL',
                            0x00000016 : 'FILE_DEVICE_PARALLEL_PORT',
                            0x00000017 : 'FILE_DEVICE_PHYSICAL_NETCARD',
                            0x00000018 : 'FILE_DEVICE_PRINTER',
                            0x00000019 : 'FILE_DEVICE_SCANNER',
                            0x0000001c : 'FILE_DEVICE_SCREEN',
                            0x00000037 : 'FILE_DEVICE_SERENUM',
                            0x0000001a : 'FILE_DEVICE_SERIAL_MOUSE_PORT',
                            0x0000001b : 'FILE_DEVICE_SERIAL_PORT',
                            0x00000031 : 'FILE_DEVICE_SMARTCARD',
                            0x0000002e : 'FILE_DEVICE_SMB',
                            0x0000001d : 'FILE_DEVICE_SOUND',
                            0x0000001e : 'FILE_DEVICE_STREAMS',
                            0x0000001f : 'FILE_DEVICE_TAPE',
                            0x00000020 : 'FILE_DEVICE_TAPE_FILE_SYSTEM',
                            0x00000038 : 'FILE_DEVICE_TERMSRV',
                            0x00000021 : 'FILE_DEVICE_TRANSPORT',
                            0x00000022 : 'FILE_DEVICE_UNKNOWN',
                            0x0000002c : 'FILE_DEVICE_VDM',
                            0x00000023 : 'FILE_DEVICE_VIDEO',
                            0x00000024 : 'FILE_DEVICE_VIRTUAL_DISK',
                            0x00000025 : 'FILE_DEVICE_WAVE_IN',
                            0x00000026 : 'FILE_DEVICE_WAVE_OUT',
                            })]],
            }],
    '_DRIVER_OBJECT': [None, {
            'MajorFunction': [None, ['IndexedArray', dict(
                        index_table={
                            'IRP_MJ_CREATE': 0,
                            'IRP_MJ_CREATE_NAMED_PIPE': 1,
                            'IRP_MJ_CLOSE': 2,
                            'IRP_MJ_READ': 3,
                            'IRP_MJ_WRITE': 4,
                            'IRP_MJ_QUERY_INFORMATION': 5,
                            'IRP_MJ_SET_INFORMATION': 6,
                            'IRP_MJ_QUERY_EA': 7,
                            'IRP_MJ_SET_EA': 8,
                            'IRP_MJ_FLUSH_BUFFERS': 9,
                            'IRP_MJ_QUERY_VOLUME_INFORMATION': 10,
                            'IRP_MJ_SET_VOLUME_INFORMATION': 11,
                            'IRP_MJ_DIRECTORY_CONTROL': 12,
                            'IRP_MJ_FILE_SYSTEM_CONTROL': 13,
                            'IRP_MJ_DEVICE_CONTROL': 14,
                            'IRP_MJ_INTERNAL_DEVICE_CONTROL': 15,
                            'IRP_MJ_SHUTDOWN': 16,
                            'IRP_MJ_LOCK_CONTROL': 17,
                            'IRP_MJ_CLEANUP': 18,
                            'IRP_MJ_CREATE_MAILSLOT': 19,
                            'IRP_MJ_QUERY_SECURITY': 20,
                            'IRP_MJ_SET_SECURITY': 21,
                            'IRP_MJ_POWER': 22,
                            'IRP_MJ_SYSTEM_CONTROL': 23,
                            'IRP_MJ_DEVICE_CHANGE': 24,
                            'IRP_MJ_QUERY_QUOTA': 25,
                            'IRP_MJ_SET_QUOTA': 26,
                            'IRP_MJ_PNP': 27
                            },
                        target="Pointer",
                        target_args=dict(target="Function"),
                        )]],
            }],
    }


#--------------------------------------------------------------------------------
# object classes
#--------------------------------------------------------------------------------
class _DEVICE_OBJECT(obj.CType):
    "Class for device objects"

    def next_devices(self):
        """Iterate over all the devices in the NextDevice entry."""
        while self:
            yield self
            self = self.NextDevice.dereference()

    def attached_devices(self):
        "Enumerate the device's attachees"
        device = self.AttachedDevice.dereference()
        while device:
            yield device
            device = device.AttachedDevice.dereference()


class DeviceModification(obj.ProfileModification):
    @classmethod
    def modify(cls, profile):
        profile.add_classes({
                '_DEVICE_OBJECT': _DEVICE_OBJECT,
                })
        profile.add_overlay(overlay)


#--------------------------------------------------------------------------------
# devicetree plugin
#--------------------------------------------------------------------------------

class DeviceTree(filescan.DriverScan):
    "Show device tree."

    __name = "devicetree"

    def __init__(self, **kwargs):
        super(DeviceTree, self).__init__(**kwargs)
        self.profile = DeviceModification(self.profile)

    def render(self, renderer):
        for object_obj, driver_obj, _, _ in self.generate_hits():
            renderer.format("DRV 0x{0:08x} {1}\n", driver_obj.obj_offset,
                            driver_obj.DriverName.v(vm=self.kernel_address_space))

            first_device = driver_obj.DeviceObject.dereference(
                vm=self.kernel_address_space)

            for device in first_device.next_devices():
                device_header = self.profile.Object(
                    "_OBJECT_HEADER", offset = device.obj_offset -
                    device.obj_profile.get_obj_offset("_OBJECT_HEADER", "Body"),
                    vm = device.obj_vm)

                device_name = device_header.NameInfo.Name.v(
                    vm=self.kernel_address_space)

                renderer.format("---| DEV {0:#x} {1} {2}\n", device.obj_offset,
                                device_name, device.DeviceType)

                level = 0

                for att_device in device.attached_devices():
                    renderer.format(
                        "------{0}| ATT {1:#x} {2} {3} - {4}\n",
                        "---" * level,
                        att_device.obj_offset,
                        device_name,
                        att_device.DriverObject.DriverName,
                        att_device.DeviceType)

                    level += 1

#--------------------------------------------------------------------------------
# driverirp plugin
#--------------------------------------------------------------------------------

class DriverIrp(filescan.DriverScan):
    "Driver IRP hook detection"

    __name = "driverirp"

    mod_re = None

    @classmethod
    def args(cls, parser):
        """Declare the command line args we need."""
        super(DriverIrp, cls).args(parser)
        parser.add_argument("-r", "--regex",
                            help = 'Analyze drivers matching REGEX')
        parser.add_argument("-v", "--verbose", default=False,
                            action="store_true", help="Show more details.")

    def __init__(self, regex=None, verbose=False, **kwargs):
        super(DriverIrp, self).__init__(**kwargs)
        self.profile = DeviceModification(self.profile)
        self.verbose = verbose
        if regex:
            self.mod_re = re.compile(regex, re.I)

    def render(self, renderer):
        module_plugin = self.session.plugins.modules()

        renderer.table_header([('i', "index", ">4"),
                               ('Funcs', "function", "36"),
                               ('addr', "func_addres", '[addrpad]'),
                               ('name', "name", '')
                               ])

        for object_obj, driver_obj, _, driver_name in self.generate_hits():
            # Continue if a regex was supplied and it doesn't match
            if self.mod_re and not self.mod_re.search(driver_name):
                continue

            # Write the standard header for each driver object
            renderer.section()

            renderer.format("DriverName: {0}\n", driver_name)
            renderer.format("DriverStart: {0:#x}\n", driver_obj.DriverStart)
            renderer.format("DriverSize: {0:#x}\n", driver_obj.DriverSize)
            renderer.format("DriverStartIo: {0:#x}\n", driver_obj.DriverStartIo)

            # Write the address and owner of each IRP function
            for i, function in enumerate(driver_obj.MajorFunction):
                # Make sure this is in the kernel address space.
                function = driver_obj.MajorFunction[i].dereference(
                    vm=self.kernel_address_space)

                # Which module does this function come from?
                module = module_plugin.find_module(function)

                renderer.table_row(i, function.obj_name, function.obj_offset,
                                   module.FullDllName)

                # For verbose we print a bit about the function
                # (e.g. disassembly if available.).
                if self.verbose:
                    renderer.format("{0}\n\n", function)
